---
sort: 1
---

# 消息队列

## 性能优化

1. 消息积压了该如何处理？
- 发送端性能优化
    - 聚包，缺点：损失实时性
    - 并发，有极限
- 消费端性能优化
    - 在设计系统的时候，一定要保证消费端的消费性能要高于生产端的发送性能
    - 在收到消息的回调方法中，不处理任何业务逻辑，把这个消息放到一个内存队列里面就返回了

## 异步编程

使用异步编程模型，虽然并不能加快程序本身的速度，但可以减少或者避免线程等待，只用很少的线程就可以达到超高的吞吐能力。

1. 如何用异步设计提高网络性能？

异步设计是一种编程范式，它允许在等待I/O操作完成的同时执行其他任务，而不是阻塞等待。这种设计可以进一步提升I/O多路复用的性能，因为它可以减少上下文切换的开销，并允许在单个线程或进程中处理更多的并发操作。
以下是几种使用异步设计来提升I/O多路复用性能的方法：
1. **使用非阻塞I/O**: 确保所有的I/O操作都是非阻塞的，这样在I/O操作不能立即完成时，程序可以继续执行其他任务。
2. **事件驱动编程**: 采用事件驱动模型，其中程序的执行是由外部事件（如网络事件、文件I/O事件）驱动的。这通常涉及到设置回调函数，当特定事件发生时，这些函数会被调用。
3. **使用异步API**: 许多现代编程语言和框架提供了异步API，这些API可以让你以非阻塞的方式执行I/O操作。例如，Python的`asyncio`模块、Node.js的异步I/O模型、C++的`std::async`和`std::future`。
4. **利用多线程或多进程**: 即使是在使用I/O多路复用的程序中，也可以通过多线程或多进程来进一步提高性能。例如，你可以使用一个线程来处理所有的I/O多路复用逻辑，而使用其他线程来执行阻塞或计算密集型的任务。
5. **使用协程**: 协程是一种轻量级的线程，它可以挂起自己的执行并在稍后恢复，而无需进行上下文切换。协程特别适合用于异步编程，因为它们可以简化异步代码的结构，使其看起来像同步代码一样。
6. **优化事件循环**: 在事件驱动模型中，事件循环是核心组件，它负责监听事件并将它们分派给相应的处理程序。优化事件循环的效率和性能是提升整体程序性能的关键。
7. **限制并发连接数**: 虽然I/O多路复用可以处理大量的并发连接，但是过多的连接可能会导致资源耗尽。合理地限制并发连接数，可以确保系统资源的有效利用。
8. **使用高效的数据结构和算法**: 在处理大量并发连接时，使用高效的数据结构和算法来管理连接和事件，可以减少内存使用和提高处理速度。
9. **监控和调优**: 使用性能监控工具来跟踪系统的性能指标，并根据监控结果进行调优。这包括调整I/O多路复用实例的大小、优化事件处理逻辑等。
通过结合异步设计和I/O多路复用，你可以创建高性能的网络应用程序，这些应用程序能够有效地处理大量的并发连接，同时保持资源的合理使用和良好的响应时间。

## 序列化与反序列化

需求：
- 网络传输数据的基本形式就是二进制字节流流，也就是一段一段的 1 和 0。
- 我们编写的程序中需要通过网络传输的数据是结构化的数据，可以是一个类或者一个结构体。
- 要想使用网络框架的 API 来传输结构化的数据，必须得先实现结构化的数据与字节流之间的双向转换。

解决：
- 这种将结构化数据转换成字节流的过程，我们称为序列化，反过来转换，就是反序列化。

1. 在内存里存放的任何数据，它最基础的存储单元也是二进制比特，也就是说，我们应用程序操作的对象，它在内存中也是使用二进制存储的，既然都是二进制，为什么不能直接把内存中，对象对应的二进制数据直接通过网络发送出去，或者保存在文件中呢？为什么还需要序列化和反序列化呢？

理论上是可行的，实际上，网络传输和文件存储确实是以二进制形式进行的。但是，直接将内存中的对象对应的二进制数据发送出去或保存在文件中，会遇到以下几个问题：
1. **内存布局**：对象在内存中的布局是由程序的编译器和操作系统决定的，它包括了对象的字段、继承关系、虚函数表等信息。这些信息对于接收端来说可能是没有意义的，除非接收端有完全相同的内存布局。
2. **平台依赖**：不同平台（如x86、ARM、不同的操作系统等）在内存对齐、字节序（大端或小端）等方面可能存在差异。直接传输可能会导致在不同平台间无法正确解析数据。
3. **地址引用**：对象在内存中可能包含指向其他对象的引用或指针。这些地址在当前进程中是有意义的，但是一旦通过网络发送或在另一进程或机器上反序列化，这些地址将不再有效。
4. **动态类型和继承**：在面向对象的语言中，对象的实际类型可能在其继承层次结构中动态变化。直接序列化二进制数据可能无法正确地处理这种动态类型信息。
5. **数据的完整性**：直接传输内存中的二进制数据可能会包含不应该被序列化的部分，如对象的内部状态、锁等。

序列化和反序列化的目的就是为了解决上述问题，它通过将对象转换为一个平台无关、可传输的格式，确保数据能够在不同的环境之间正确地传递和重建。序列化格式通常是文本（如JSON、XML）或二进制（如Protocol Buffers、MessagePack），这些格式定义了数据的结构和类型信息，使得数据可以在不同的系统和编程语言之间进行交换。
总结来说，序列化和反序列化是必要的，因为它们提供了一种标准化的方法来打包和解析数据，确保数据的可移植性和互操作性。

## 传输协议

传输协议是应用程序之间对话的语言。
设计：
- 如何“断句”？
    - 给每句话前面加一个表示这句话长度的数字，收到数据的时候，我们按照长度来读取就可以了。比如：`03 下雨天 03 留客天 02 天留 03 我不留`
- 用双工收发协议提升吞吐量，如何解决请求响应对不上？
    - 发送请求的时候，给每个请求加一个序号，这个序号在本次会话内保证唯一，然后在响应中带上请求的序号，这样就可以把请求和响应对应上了。