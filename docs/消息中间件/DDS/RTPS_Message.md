---
sort: 2
---

# RTPS消息模块


- **消息结构（Message Structure）**
    - **总体结构**
        - 由固定大小的消息头和可变数量的子消息组成
        - 子消息由子消息头和可变数量的子消息元素组成
    - **消息头（Header）**
        - 包含协议版本、供应商等信息
        - 用于识别消息所属的协议和版本
    - **子消息头（SubmessageHeader）**
        - 包含子消息类型、标志等信息
        - 用于识别子消息的类型和可选元素
    - **子消息元素（SubmessageElements）**
        - 包含各种类型的信息，如实体ID、序列号等
        - 是构建子消息的基本单元

## **消息类型（Message Types）**
- **实体子消息（Entity Submessages）**
    - 包含应用数据对象的值
    - 如Data、DataFrag等
- **解释器子消息（Interpreter Submessages）**
    - 修改RTPS接收器状态
    - 如InfoSource、InfoDestination等
    
## **消息处理（Message Processing）**
- **消息接收器（Message Receiver）**
    - 维护状态以解释子消息
    - 遵循一定规则处理消息
- **消息有效性（Message Validity）**
    - 消息头和子消息需满足一定条件才有效
    - 无效消息会被忽略或导致整个消息无效

## 消息头在消息模块中具有以下具体作用

1. **协议识别**
   - 用于识别消息所属的协议。消息头中的`protocol`字段被设置为`PROTOCOL_RTPS`，明确该消息是遵循RTPS协议的。
2. **版本确定**
   - 确定协议的版本。`version`字段标识了RTPS协议的版本，例如在文档中提到的版本2（`major = 2`，`minor = 4`）会被设置为`PROTOCOLVERSION`，帮助接收方了解消息所遵循的具体协议版本规范。
3. **供应商标识**
   - 表明发送消息的供应商。`vendorld`字段指示了提供RTPS协议实现的供应商，不同供应商可能会有不同的扩展或实现细节，接收方可以据此进行相应处理。
4. **GUID前缀定义**
   - 定义一个默认前缀用于消息中出现的GUIDs。`guidPrefix`字段允许子消息只包含GUID的`EntityId`部分，节省了在每个GUID上重复公共前缀的开销，有助于在重建消息中的GUID时提供统一的前缀基础。

## 消息模块中的子消息头和子消息元素有哪些常见类型

### 子消息头（SubmessageHeader）常见类型
1. **标识类型（submessageld）**
   - 用于识别子消息的种类。例如在版本2.4的协议中定义了多种类型，包括`DATA`、`GAP`、`HEARTBEAT`、`ACKNACK`、`PAD`、`INFO TS`、`INFO REPLY`、`INFO DST`、`INFO SRC`、`DATA FRAG`、`NACK FRAG`、`HEARTBEAT FRAG`等。
2. **标志类型（flags）**
   - 包含8个布尔值，其中第一个标志`EndiannessFlag`用于表示子消息编码的字节序（大端或小端）。其他标志的解释因子消息类型而异。
3. **长度类型（submessageLength）**
   - 表示子消息的长度（不包括子消息头）。这个长度信息对于确定子消息的边界以及在消息中定位下一个子消息非常重要。

### 子消息元素（SubmessageElements）常见类型
1. **实体相关（GuidPrefix、EntityId）**
   - `GuidPrefix`和`EntityId`用于在子消息中包含`GUID_t`的相关部分，用于识别消息的源或目标实体。
2. **供应商相关（VendorId）**
   - 用于识别实现RTPS协议的中间件供应商，允许供应商添加特定的协议扩展。
3. **协议版本相关（ProtocolVersion）**
   - 定义了RTPS协议的版本，包括主版本和次版本号。
4. **序列号相关（SequenceNumber、SequenceNumberSet）**
   - `SequenceNumber`是一个64位有符号整数，用于为每个消息或数据变化提供唯一的序号。`SequenceNumberSet`用于提供一组序列号的二进制信息，可用于选择性地请求重新发送一组序列号。
5. **片段相关（FragmentNumber、FragmentNumberSet）**
   - `FragmentNumber`是一个32位无符号整数，用于识别碎片化序列化数据中的特定片段。`FragmentNumberSet`用于提供一组片段号的二进制信息，可用于选择性地请求重新发送一组片段。
6. **时间戳相关（Timestamp）**
   - 用于表示时间，要求能够具有纳秒级或更好的分辨率，有`TIME_ZERO`、`TIME_INVALID`、`TIME_INFINITE`等特殊值。
7. **参数列表相关（ParameterList）**
   - 用于包含可能影响消息解释的QoS参数，遵循一种允许扩展QoS而不破坏向后兼容性的机制。
8. **计数相关（Count）**
   - 用于使接收方能够检测到相同子消息的重复。
9. **定位器相关（LocatorList）**
   - 用于指定一组定位器，定位器包含了传输所需的地址等信息。
10. **序列化数据相关（SerializedData、SerializedDataFragment）**
   - `SerializedData`包含数据对象值的序列化表示，`SerializedDataFragment`包含已碎片化的数据对象的序列化表示，RTPS协议不解释这些序列化数据流，将其视为不透明数据。
11. **组摘要相关（GroupDigest）**
   - 用于以紧凑的方式传达一组`EntityId_t`，用于标识属于同一参与者的一组实体。

## 消息模块中的消息处理机制是怎样的？

### 消息接收器（Message Receiver）维护状态
1. **状态重置**
   - 对于每个新消息，接收器的状态会被重置并初始化为特定值。例如，`sourceVersion`被设置为`PROTOCOLVERSION`，`sourceVendorId`被设置为`VENDORID_UNKNOWN`，`sourceGuidPrefix`被设置为`GUIDPREFIX_UNKNOWN`等。
2. **状态维护规则**
   - 接收器必须维护从同一消息中先前反序列化的子消息的状态，这个状态被建模为RTPS接收器的状态，为子消息的解释提供上下文。

### 消息处理规则
1. **子消息头读取规则**
   - 如果无法读取完整的子消息头，消息的其余部分将被视为无效。
2. **子消息长度字段规则**
   - `submessageLength`字段定义了下一个子消息的起始位置或指示子消息是否延伸到消息末尾。如果该字段无效，消息的其余部分无效。
3. **未知子消息ID处理规则**
   - 具有未知`SubmessageId`的子消息必须被忽略，解析应继续处理下一个子消息。例如，RTPS 2.4实现必须忽略任何在版本2.4中定义的`SubmessageKind`集合之外的子消息ID，以及来自未知`vendorId`的供应商特定范围内的子消息ID。
4. **子消息标志处理规则**
   - 接收器应忽略未知的标志。例如，RTPS 2.4实现应该跳过协议中标记为“X”（未使用）的所有标志。
5. **有效子消息长度使用规则**
   - 必须始终使用有效的`submessageLength`字段来查找下一个子消息，即使对于已知ID的子消息也是如此。
6. **已知但无效子消息处理规则**
   - 一个已知但无效的子消息会使消息的其余部分无效。

### 消息对接收器状态和端点行为的影响
1. **接收器状态改变**
   - 消息中的某些子消息（如`Header`、`InfoSource`、`InfoReply`、`InfoDestination`、`InfoTimestamp`）可以改变接收器的状态，影响后续子消息的解释。
2. **端点行为影响**
   - 基本的RTPS消息（如`Data`、`DataFrag`、`HeartBeat`、`AckNack`、`Gap`、`HeartbeatFrag`、`NackFrag`）可以影响消息所指向的端点的行为。

## 如何优化消息处理机制以提高系统性能？

### 1. 优化子消息组合
 - **合并相似子消息**
   - 某些子消息在设计上可以包含关于一组序列号或其他信息的集合，但在实际协议描述的虚拟机器中可能未充分利用这一特性。例如，`Gap`和`AckNack`子消息都可用于传达关于序列号的信息。通过合理组合这些子消息，可以减少消息数量，提高带宽和CPU利用率。比如，如果多个`Gap`或`AckNack`消息可以合并为一个包含所有相关序列号信息的单个消息，就能避免多次发送相似的控制信息，减少网络传输开销和接收端处理负担。
 - **利用协议允许的合并机制**
   - RTPS协议允许将不同种类的子消息合并到单个RTPS消息中，这一特性可被充分利用。例如，`Data`子消息可以和`HeartBeat`子消息合并发送，这样RTPS写者可以在发送数据变化的同时明确请求对所发送变化的确认，无需额外发送单独的`HeartBeat`消息，减少了网络流量，提高了整体性能。

### 2. 优化子消息发送策略
 - **合理安排发送顺序**
   - 对于像`DataFrag`这样用于处理大数据分片的子消息，发送顺序至关重要。应按照片段编号递增的顺序发送`DataFrag`子消息，这样接收端可以更高效地重组数据。同时，如果某个传输不需要对数据进行分片（例如某些具有较大消息尺寸限制的传输），则应直接发送常规的`Data`子消息，避免不必要的分片和重组操作，提高数据传输效率。
 - **避免冗余发送**
   - 在发送包含QoS参数的`DataFrag`子消息时，对于给定的写者序列号码，只需在第一个`DataFrag`子消息中包含QoS参数即可，后续相同序列号码的`DataFrag`子消息无需重复发送这些参数，减少了消息的冗余信息，节省网络带宽。

### 3. 优化接收器实现
 - **高效查找未发送变化**
   - 在实现`ReaderProxy`时，为了高效查找未发送的变化，可以通过维护一个单一的序列号（如`highestSeqNumSent`）来记录发送给`ReaderProxy`的任何缓存变化的最高序列号。利用这个序列号，可以通过查找历史缓存中序列号大于`highestSeqNumSent`的变化来实现`unsent_changes()`操作，通过查找历史缓存中比`highestSeqNumSent`大且最接近的下一个序列号对应的变化来实现`next_unsent_change()`操作。这样可以避免对整个历史缓存进行遍历，提高查找效率。
 - **利用滑动窗口处理请求变化**
   - 对于处理请求的变化（如`requested_changes()`等操作），可以维护一个滑动窗口来存储相关的序列号信息。通过使用一个固定长度的位图和一个最低请求变化的序列号，可以高效地表示哪些序列号是当前被请求的。对于不在窗口内的请求，可以忽略，因为这些请求对应的序列号可能过高，接收端可能会重新发送请求，从而避免了对过多不必要请求的处理，提高了性能。

## 介绍一下消息处理机制的常见问题及解决方法

### 常见问题
1. **子消息头读取问题**
   - 如果无法完整读取子消息头，整个消息会被视为无效。例如，网络传输错误可能导致子消息头部分数据丢失。
2. **子消息长度字段问题**
   - 子消息长度字段定义了下一个子消息的起始位置，如果该字段无效，会导致消息解析错误。比如，长度字段的值可能由于传输错误被篡改，使得接收方无法正确定位下一个子消息。
3. **未知子消息ID问题**
   - 遇到未知的子消息ID时，如果不进行正确处理，会影响消息的正常解析。例如，不同版本的协议可能定义了新的子消息类型，旧版本的接收方可能无法识别。
4. **子消息标志问题**
   - 接收器可能会遇到未知的子消息标志，如何处理这些未知标志会影响消息处理的正确性。比如，一些供应商可能会在未来版本中使用新的标志，但旧版本的接收方可能无法理解其含义。
5. **有效子消息长度使用问题**
   - 没有正确使用有效子消息长度来查找下一个子消息，可能导致消息解析错误。例如，在复杂的消息结构中，如果没有按照规则使用长度信息，可能会跳过或错误解析子消息。
6. **已知但无效子消息问题**
   - 当一个已知的子消息但内容无效时，如果不进行正确处理，会影响整个消息的有效性。例如，某个`Data`子消息的`writerSN`值不符合要求，可能会导致整个消息无法正确处理。

### 解决方法
1. **严格遵循消息处理规则**
   - 接收方必须严格按照协议规定的算法和规则处理消息。例如，对于子消息头读取，要确保完整接收后再进行后续处理；对于子消息长度字段，要依据其定义正确定位下一个子消息。
2. **版本兼容性处理**
   - 对于未知的子消息ID和标志，要根据协议版本进行合理处理。例如，在较新版本中引入的子消息ID，如果在旧版本接收方中遇到，应按照协议规定忽略并继续处理下一个子消息。对于未知标志，RTPS 2.4实现应该跳过协议中标记为“X”（未使用）的所有标志。
3. **错误处理和恢复机制**
   - 当遇到无效子消息时，要采取适当的错误处理和恢复机制。例如，如果一个`Data`子消息无效，可以记录错误信息，同时继续处理后续可能有效的消息，避免因为一个子消息的错误导致整个消息处理流程中断。
4. **状态维护和更新**
   - 正确维护和更新接收器的状态，确保消息的正确解释。例如，根据接收到的`Header`、`InfoSource`、`InfoReply`、`InfoDestination`、`InfoTimestamp`等子消息正确更新接收器状态，以便后续子消息能够在正确的上下文中被解释。

## 如何确保消息处理机制的优化在各种网络环境下都能正常工作？

### 1. 考虑网络特性差异
 - **不同网络带宽环境**
   - 在低带宽网络环境下，优化应侧重于减少消息数量和大小，以降低网络传输负担。例如，通过合并子消息、避免冗余信息发送等方式，确保消息能够在有限的带宽下高效传输。在高带宽网络环境中，虽然带宽资源相对充足，但仍要避免不必要的消息发送，以提高系统整体性能和实时性。
 - **不同网络延迟特性**
   - 对于高延迟网络，如卫星通信网络，优化的消息处理机制应注重减少消息往返次数。例如，合理安排消息发送顺序和合并相关消息，使得一次消息传输能够包含更多有效信息，减少因网络延迟导致的系统响应延迟。在低延迟网络环境下，如局域网，可以更注重消息处理的实时性和准确性，利用低延迟的优势提高系统性能。
 - **网络可靠性差异**
   - 在可靠性较低的网络环境中，如无线网络容易出现信号干扰和丢包情况，优化应加强消息的可靠性保障。例如，通过增强错误检测和恢复能力，如更严格地维护序列号和滑动窗口，及时检测和处理消息丢失或重复问题，确保消息能够可靠传输。在可靠性较高的网络环境中，如光纤网络，可以在保证可靠性的基础上，进一步优化消息处理效率。

### 2. 进行充分的测试和验证
 - **模拟不同网络环境测试**
   - 在实验室环境中，使用网络模拟器工具模拟各种网络环境，包括不同的带宽、延迟、丢包率等情况。对优化后的消息处理机制进行全面测试，检查消息传输的正确性、实时性和可靠性等指标。例如，通过模拟低带宽高延迟的网络环境，测试合并子消息等优化措施是否能够有效提高消息传输效率和系统性能。
 - **实际网络环境测试**
   - 在实际的不同网络环境中进行现场测试，包括企业局域网、广域网、无线网络等。收集实际运行数据，分析优化后的消息处理机制在真实网络环境中的表现，发现并解决可能出现的问题。例如，在企业无线网络环境中测试时，可能会发现由于信号干扰导致的消息丢失问题，通过进一步优化错误检测和恢复机制来解决。

### 3. 采用自适应和可配置机制
 - **自适应调整消息处理策略**
   - 设计消息处理机制能够根据网络环境的实时监测结果自动调整处理策略。例如，如果监测到网络带宽降低，系统自动增加子消息合并的程度，减少消息发送数量；如果网络延迟增加，系统自动调整消息发送顺序，优先发送重要信息。
 - **可配置参数优化**
   - 提供可配置的参数，使得系统管理员或用户能够根据具体的网络环境进行手动调整。例如，可以设置消息合并的阈值参数，根据网络带宽情况决定是否进行更多的子消息合并；设置序列号和滑动窗口的相关参数，以适应不同网络可靠性环境下的消息处理需求。