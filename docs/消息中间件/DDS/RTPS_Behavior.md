---
sort: 2
---

# RTPS行为模块

- **概述（Overview）**
    - 描述RTPS实体动态行为
    - 定义消息交换序列和定时约束
- **互操作性要求（Interoperability Requirements）**
    - 所有实现必须满足特定行为要求
    - 包括使用规定消息、实现消息接收器等
- **不同实体行为（Entity Behaviors）**
    - **RTPS写者行为（RTPS Writer Behavior）**
        - 包括不发送无序数据、包含内联QoS值等
        - 可靠写者需定期发送心跳消息等
    - **RTPS读者行为（RTPS Reader Behavior）**
        - 可靠读者需对心跳消息响应等
        - 满足一些确认和过滤相关要求
- **参考实现（Reference Implementations）**
    - **无状态参考实现（Stateless Reference Implementation）**
        - 优化可扩展性，适用于尽力而为通信
        - 几乎不在远程实体保留状态
    - **有状态参考实现（Stateful Reference Implementation）**
        - 在远程实体保留完整状态
        - 适用于严格可靠通信，可进行过滤
- **其他行为（Other Behaviors）**
    - 包括写者活跃度协议
    - 以及对碎片化数据等可选行为的支持

## 消息交换序列和定时约束

### 消息交换序列
1. **匹配与传播原则**
   - 一旦RTPS写者与读者匹配，写者需确保其历史缓存中的`CacheChange`变化传播到读者的历史缓存中。这个传播过程是通过使用在消息模块中定义的RTPS消息进行的。
   - 例如，写者会将`CacheChange`信息通过`Data`子消息发送给读者，并可能同时发送`Heartbeat`子消息请求确认。
2. **不同实体的消息交换示例**
   - 以无状态参考实现为例，在其与读者定位器（ReaderLocator）的交互中，当读者定位器的未发送变化队列不为空时（`RL::unsent_changes()!= <empty>`），会发送相应的`Data`或`GAP`消息。如果资源允许发送（`RL::can_send() == true`），会从读者定位器获取下一个未发送变化（`a_change := RL:next_unsent_change()`）并发送。
   - 对于有状态参考实现，以写者与匹配读者的交互为例，当有新变化添加到写者的历史缓存且未发送变化队列不为空（`RP:unsent_changes()!= <empty>`）时，会发送`Data`消息尝试将变化发送给读者。如果变化相关且资源允许（`a_change.status := UNDERWAY; if (a_change.is_relevant)`），则发送`Data`消息，否则发送`GAP`消息。

### 定时约束
1. **通用定时要求**
   - 所有实现的定时特性必须是可调节的。这是因为不同的应用场景、部署配置和底层传输可能需要不同的定时设置。
   - 例如，在一些对实时性要求极高的工业控制场景中，可能需要更短的消息发送间隔和更快的响应时间；而在一些对实时性要求相对较低的数据采集场景中，可以适当放宽定时要求。
2. **写者定时约束**
   - 写者在某些情况下需要满足特定的定时要求。例如，可靠的写者必须定期向匹配的可靠读者发送`HEARTBEAT`消息，告知读者有可用的数据样本。如果没有可用样本则无需发送。
   - 并且，写者在收到`ACKNACK`消息指示读者缺少某些数据样本时，必须在一定时间内响应，可以选择发送缺失的数据样本、`GAP`消息（当样本不再相关）或`HEARTBEAT`消息（当样本不再可用）。这个响应时间可以根据具体应用需求和网络环境进行调整。
3. **读者定时约束**
   - 对于可靠读者，在收到`HEARTBEAT`消息且最终标志未设置时，必须在一定时间内响应`ACKNACK`消息。这个响应时间可以设置，以避免消息风暴同时又能满足系统的交互需求。
   - 当收到`HEARTBEAT`消息且指示有样本缺失时，读者也需要在适当时间内响应`ACKNACK`消息，并且如果读者可以容纳这些缺失样本，就必须进行响应。

## 互操作性要求

### 1. 通用要求
 - **使用规定消息**
   - 所有通信必须使用在消息模块中定义的RTPS消息，不能使用其他未规定的消息类型。这确保了不同供应商实现的RTPS系统之间能够使用统一的消息格式进行通信。
   - 例如，写者与读者之间的数据传输、心跳检测、确认反馈等操作都必须使用标准的RTPS消息，如`Data`、`Heartbeat`、`ACKNACK`等子消息。
 - **实现消息接收器**
   - 所有实现必须实现RTPS消息接收器，并且遵循其规则来解释子消息和维护消息接收器的状态。
   - 消息接收器要能够正确处理子消息头中的各种信息，如子消息类型标识、标志位等，以及根据子消息长度字段正确定位下一个子消息。同时，要根据接收到的子消息更新自身状态，为后续子消息的解释提供正确的上下文。

### 2. 定时特性要求
 - **可调节定时特性**
   - 所有实现的定时特性必须是可调节的。这是因为不同的应用场景、部署配置和底层传输可能需要不同的定时设置。
   - 例如，在一些对实时性要求极高的工业控制场景中，可能需要更短的消息发送间隔和更快的响应时间；而在一些对实时性要求相对较低的数据采集场景中，可以适当放宽定时要求。

### 3. 发现协议要求
 - **实现发现协议**
   - 所有实现必须实现简单参与者和端点发现协议，以实现远程端点的发现。这是因为在分布式系统中，参与者需要能够自动发现其他参与者及其端点，才能建立有效的通信。
   - 例如，通过简单参与者发现协议（SPDP）和简单端点发现协议（SEDP），参与者可以交换关于自身和端点的信息，从而实现动态的网络配置和通信建立。

## 不同实体行为

### RTPS写者行为
1. **数据发送顺序要求**
   - 写者必须按照数据添加到历史缓存的顺序发送数据样本，不能发送无序数据。这确保了接收方能够按照正确的顺序接收和处理数据，维护数据的一致性和完整性。
   - 例如，如果有多个数据变化依次添加到写者的历史缓存，写者应按照添加的先后顺序将这些数据变化通过`Data`子消息发送给读者。
2. **内联QoS值处理**
   - 如果读者请求，写者必须包含内联QoS值。内联QoS值可以影响读者对数据消息的解释和处理方式，写者需要根据读者的要求正确提供这些信息。
   - 例如，当读者配置为需要特定的QoS参数（如可靠性级别、数据生命周期等）时，写者在发送`Data`子消息时应在消息中包含相应的内联QoS参数。
3. **心跳消息发送（可靠写者）**
   - 可靠的写者必须定期向每个匹配的可靠读者发送`HEARTBEAT`消息，告知读者有可用的数据样本。如果没有可用样本则无需发送。
   - 例如，在一个工业自动化系统中，可靠写者可能每隔一定时间（如10秒）向相关读者发送`HEARTBEAT`消息，告知读者其状态和是否有新的数据可供读取。
4. **对负确认的响应（可靠写者）**
   - 当可靠写者收到`ACKNACK`消息指示读者缺少某些数据样本时，必须响应。可以选择发送缺失的数据样本、`GAP`消息（当样本不再相关）或`HEARTBEAT`消息（当样本不再可用）。
   - 例如，如果读者通过`ACKNACK`消息告知写者某个数据样本缺失，写者可以根据自身的逻辑和样本的实际情况，决定是重新发送该数据样本，还是发送`GAP`消息表示该样本已不再相关，或者发送`HEARTBEAT`消息表示该样本当前不可用。
5. **发送写者组信息相关消息**
   - 属于一个组的写者即使读者已经确认了所有该写者的样本，也应向匹配的读者发送`HEARTBEAT`或`GAP`子消息。这是为了让读者能够检测到该组中不可用的组序列号码。
   - 例如，在一个分布式传感器网络中，多个传感器作为写者属于同一个组，即使某个读者已经接收了所有来自该组某个写者的样本，该写者仍需发送相关消息，以便读者了解整个组的状态。

### RTPS读者行为
1. **对心跳消息的响应（可靠读者）**
   - 可靠读者在收到`HEARTBEAT`消息且最终标志未设置时，必须响应`ACKNACK`消息。该`ACKNACK`消息可能确认已经收到所有数据样本，也可能指示某些数据样本缺失。
   - 例如，在一个实时数据监控系统中，可靠读者在收到写者发送的`HEARTBEAT`消息且最终标志未设置时，会及时发送`ACKNACK`消息反馈自己的接收情况。
2. **对缺失样本心跳消息的响应（可靠读者）**
   - 可靠读者在收到`HEARTBEAT`消息且指示有样本缺失时，必须响应`ACKNACK`消息指示哪些数据样本缺失。前提是读者可以容纳这些缺失样本且不受最终标志设置的影响。
   - 例如，在一个数据采集系统中，如果读者收到写者的`HEARTBEAT`消息并发现有样本缺失，且自己的缓存有足够空间容纳这些缺失样本，就会发送`ACKNACK`消息告知写者哪些样本缺失。
3. **确认和过滤相关要求**
   - 一旦读者确认接收一个样本，就不能再对该样本进行负确认。并且读者只能在收到`HEARTBEAT`消息时发送`ACKNACK`消息作为响应（在初始发现写者时可以作为优化提前发送`ACKNACK`消息，但写者无需响应这些预发的`ACKNACK`消息）。
   - 例如，在一个消息传递系统中，读者一旦通过`ACKNACK`消息确认接收了某个数据样本，后续即使出现异常情况也不能再发送负确认消息。同时，读者不会随意发送`ACKNACK`消息，而是只有在收到写者的`HEARTBEAT`消息时才会根据情况发送相应的`ACKNACK`消息。

## 行为模块中的参考实现

### 无状态参考实现
1. **特点**
   - 优化可扩展性，适用于尽力而为通信。它几乎不在远程实体保留状态，通过减少对远程实体状态的维护，能够更好地适应大规模分布式系统中大量参与者和端点的情况。
   - 例如，在一个大型物联网系统中，有大量的传感器作为写者发送数据，无状态参考实现可以更高效地处理这些传感器的数据传输，因为它不需要为每个传感器维护大量的状态信息。
2. **行为示例**
   - 以与读者定位器（ReaderLocator）的交互为例，当读者定位器的未发送变化队列不为空时（`RL::unsent_changes()!= <empty>`），会发送相应的`Data`或`GAP`消息。如果资源允许发送（`RL::can_send() == true`），会从读者定位器获取下一个未发送变化（`a_change := RL:next_unsent_change()`）并发送。
   - 在处理可靠通信时，如果收到`ACKNACK`消息，会根据消息中的信息进行处理，但不会像有状态参考实现那样维护大量关于读者的状态信息。

### 有状态参考实现
1. **特点**
   - 在远程实体保留完整状态。这种方式虽然需要更多的内存来维护状态信息，但可以更好地保证数据传输的可靠性，适用于对可靠性要求较高的应用场景。
   - 例如，在一个金融交易系统中，数据的准确性和完整性至关重要，有状态参考实现可以通过维护每个读者的详细状态信息，确保每一笔交易数据都能准确无误地传输和处理。
2. **行为示例**
   - 以写者与匹配读者的交互为例，当有新变化添加到写者的历史缓存且未发送变化队列不为空（`RP:unsent_changes()!= <empty>`）时，会发送`Data`消息尝试将变化发送给读者。如果变化相关且资源允许（`a_change.status := UNDERWAY; if (a_change.is_relevant)`），则发送`Data`消息，否则发送`GAP`消息。
   - 对于收到的`ACKNACK`消息，有状态参考实现会根据消息中的信息更新读者的状态信息，如记录哪些样本已经被读者确认接收等，以便更好地管理和控制数据传输过程。

### 有状态实现维护了对端哪些信息

### 有状态实现如何应对网络拥塞？

