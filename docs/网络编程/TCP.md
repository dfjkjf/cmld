---
sort: 10
---

# TCP

## TCP头部信息

TCP头部包含了多个字段，每个字段都有其特定的功能，以下是一些主要的TCP头部字段及其功能：
1. **源端口（Source Port）**：
   - 16位字段，标识发送TCP段的端口号。
2. **目标端口（Destination Port）**：
   - 16位字段，标识接收TCP段的端口号。
3. **序列号（Sequence Number）**：
   - 32位字段，用于标识发送数据段中第一个字节的序列号。它用于确保数据的正确顺序和重传管理。
4. **确认号（Acknowledgment Number）**：
   - 32位字段，用于确认接收方期望从发送方收到的下一个序列号。这用于确认已经成功接收的数据。
5. **数据偏移（Data Offset）**：
   - 4位字段，表示TCP头部长度，以32位字为单位。这个字段也隐含了选项字段的长度。
6. **保留（Reserved）**：
   - 6位字段，当前保留供将来使用，必须设置为0。
7. **控制位（Control Flags）**：
   - 6个单独的位，每个都有特定的控制功能：
     - URG（紧急指针有效）
     - ACK（确认字段有效）
     - PSH（推送功能，要求接收方尽快将数据推送给应用层）
     - RST（重置连接）
     - SYN（同步序列编号，用于建立连接）
     - FIN（结束连接）
8. **窗口大小（Window Size）**：
   - 16位字段，用于流量控制，表示接收方可以接收的数据量（以字节为单位）。
9. **校验和（Checksum）**：
   - 16位字段，用于检测TCP头部和数据部分的错误。
10. **紧急指针（Urgent Pointer）**：
    - 16位字段，仅在URG标志设置为1时有效，指出紧急数据的结束位置。
11. **选项（Options）**：
    - 可变长度的字段，提供了多种选项，包括最大报文段长度（MSS）、窗口缩放、选择性确认（SACK）、时间戳等。

### 头部中的选项

#### 最大报文段长度（Maximum Segment Size, MSS）

这个选项允许TCP连接的双方在连接建立时协商一个最大的段大小。MSS选项的值表示发送方能够接收的最大TCP数据负载（不包括TCP头）的大小。例如，如果一方通告其MSS为1460字节，那么另一方的发送方就知道它可以在一个TCP段中发送最多1460字节的数据。
   
**MSS**

最大段大小（Maximum Segment Size，MSS）是指在不进行分片的情况下，网络层（通常是IP层）能够传输的最大数据量。MSS是TCP连接建立时，双方协商的一个参数，通常用来确定TCP层每次发送数据段的大小。

对于以太网（Ethernet）这种常见的数据链路层技术，其标准最大传输单元（MTU）是1500字节。但是，MTU不包括链路层的帧头和帧尾，这些通常占用18字节（对于以太网来说）。因此，为了计算MSS，我们需要从MTU中减去IP头部和TCP头部的字节数。

IP头部通常是20字节（不包含选项），而TCP头部通常是20字节（同样不包含选项）。所以，MSS的计算方式如下：
```
MSS = MTU - IP头部大小 - TCP头部大小
MSS = 1500 - 20 - 20
MSS = 1460 字节
```
因此，对于一个标准的以太网网络，最大段大小（MSS）通常是1460字节。但是，需要注意的是，不同网络环境和配置可能会导致不同的MTU值，从而影响MSS的大小。例如，在较大的网络环境中，可能会使用更大的MTU值，如Jumbo Frames，其MTU可以达到9000字节，这将导致MSS相应增大。

#### 窗口缩放（Window Scale）

窗口缩放选项用于扩展TCP窗口大小的范围，允许在高速网络中更有效地进行流量控制。窗口缩放值是一个整数，表示窗口大小字段的左移位数。

#### 选择性确认（Selective Acknowledgment, SACK）

SACK选项允许接收方明确告知发送方哪些数据块已经成功接收，哪些需要重传。这比传统的累积确认更有效，因为它可以减少不必要的重传。

#### 时间戳

时间戳选项用于测量往返时间（RTT）和防止序列号回绕问题。它包含两个时间戳值：发送方的当前时间戳和接收方最后发送的时间戳。

这个字段主要有两个作用：
   1. **测量往返时间（RTT）**：
      - 当发送方发送一个TCP段时，它会记录下发送的时间戳。当接收方收到这个段时，会在确认（ACK）中回显这个时间戳。发送方收到ACK后，可以通过计算当前时间与原始时间戳之间的差值来估算RTT。这个信息对于调整TCP的重传计时器和其他拥塞控制参数非常重要。
   2. **识别并丢弃旧的或重复的数据包**：
      - 当TCP序列号回绕发生时，即TCP序列号空间（32位）耗尽，序列号从最大值回绕到最小值的情况。仅凭序列号无法区分新旧数据包。时间戳在这里起到了关键作用：
      - **区分新旧数据**：如果一个旧的数据包在网络中长时间滞留后到达接收方，其时间戳将会与当前连接的时间戳有很大差异。接收方可以通过比较时间戳来识别出这是一个旧的数据包，并将其丢弃，而不是将其作为有效数据处理。
      - **检测重复数据**：如果接收方收到了两个具有相同序列号的数据包，它可以通过比较时间戳来决定哪个是最新发送的。通常，时间戳较大的数据包会被认为是有效的，而时间戳较小的数据包将被丢弃。



## 3次握手

### 1. TCP的握手为什么是三次？

目的让通信双方都知道通信双方的收发功能是正常的。

![TCP握手](./imags/tcp握手.jpg)

|握手次数|效果|
|---|---|
|第一次握手|张三知道自己能发出信件；李四知道自己能收到信件；李四知道张三能发出信件|
|第二次握手|李四知道自己能发出信件；张三知道自己能收到信件；张三知道李四能发出信件；张三知道李四能收到信件|
|第三次握手|李四知道张三能收到信件|

**结论**

两次达不到，三次刚刚好，四次没必要

其实是4次握手，只是把服务器**确认收到**和**同意建立连接**合并了。

### 2. 双方交换哪些信息？

以下是三次握手的详细步骤和交换的信息：
- **第一次握手**：
  - 客户端发送一个TCP段，其中包含：
    - 客户端的初始序列号（ISN，通常是一个随机值）。
    - SYN标志，表示客户端请求建立一个连接。
- **第二次握手**：
  - 服务器接收到客户端的SYN请求后，发送一个确认的TCP段，其中包含：
    - 确认应答（ACK）标志，表示对客户端SYN的确认。
    - 确认号（ACK number），通常是客户端的序列号加1，表示期望收到客户端的下一个序列号。
    - 服务器的初始序列号。
    - SYN标志，表示服务器同意建立连接。
- **第三次握手**：
  - 客户端收到服务器的确认后，发送一个确认的TCP段，其中包含：
    - 确认应答（ACK）标志，表示对服务器SYN的确认。
    - 确认号（ACK number），通常是服务器的序列号加1，表示期望收到服务器的下一个序列号。

### 3. 三次握手中双方的状态

客户端状态变化：
- **SYN_SENT**：
   - 客户端发送一个SYN报文段，进入SYN_SENT状态。
   - 在这个状态下，客户端等待服务器的确认。
- **ESTABLISHED**：
   - 客户端收到服务器的SYN+ACK响应后，发送一个ACK报文段。
   - 发送完ACK报文段后，客户端进入ESTABLISHED状态，表示连接已经建立。

服务器状态变化：
- **LISTEN**：
   - 服务器启动时，会创建一个套接字，并将其置于LISTEN状态，等待客户端的连接请求。
- **SYN_RCVD**：
   - 服务器收到客户端的SYN报文段后，发送一个SYN+ACK报文段作为响应，并进入SYN_RCVD状态。
   - 在这个状态下，服务器等待客户端的确认。
- **ESTABLISHED**：
   - 服务器收到客户端的ACK报文段后，确认连接建立，并进入ESTABLISHED状态。
   - 此时，服务器和客户端之间的连接已经建立，可以开始数据传输。

总结一下，三次握手过程中客户端和服务器状态的变化如下：
- 客户端：CLOSED -> SYN_SENT -> ESTABLISHED
- 服务器：LISTEN -> SYN_RCVD -> ESTABLISHED

### 4. 三次握手过程中的丢包处理

- **SYN包丢失**：客户端在发送SYN后，如果没有收到服务器的响应（SYN+ACK），它会重试发送SYN，通常是指数退避策略。如果重试次数超过一定限制，客户端可能会放弃连接尝试，并通知应用层连接失败。
- **SYN+ACK包丢失**：客户端在发送SYN后，如果在一定时间内没有收到服务器的SYN+ACK，它同样会重试发送SYN。服务器也可能重发SYN+ACK，但这通常取决于具体实现。
- **ACK包丢失**：服务器在发送SYN+ACK后，如果没有收到客户端的ACK确认，它将重发SYN+ACK。如果客户端实际上已经发送了ACK但服务器没有收到，服务器可能会多次重发SYN+ACK，直到超时或者接收到ACK。

在这些情况下，TCP的可靠性机制，如超时重传、序列号和确认号，保证了连接的最终建立或者失败通知。需要注意的是，为了防止攻击，许多系统对SYN包的重传次数和频率进行了限制，以避免**SYN洪水攻击**。


## 4次挥手

### 1. 过程

- 客户端发送：一个FIN（finish）包，用来关闭客户端到服务器方向的连接。
- 服务器发送：一个ACK包，确认收到客户端的FIN包。
- 服务器发送：一个FIN包，用来关闭服务器到客户端方向的连接。
- 客户端发送：一个ACK包，确认收到服务器的FIN包。

### 2. 状态

客户端状态：
- **ESTABLISHED**:
   - 连接已建立，客户端可以开始发送和接收数据。
- **FIN-WAIT-1**:
   - 客户端发送了FIN包，等待服务器的确认（ACK）。
- **FIN-WAIT-2**:
   - 客户端收到服务器的ACK确认，等待服务器发送FIN包。
- **TIME-WAIT**:
   - 客户端发送了最后的ACK包，并等待足够的时间（2MSL）以确保服务器收到了这个ACK包，防止已关闭的连接中延迟的数据包干扰新连接。
- **CLOSED**:
   - 2MSL时间后，客户端完整地关闭连接。

服务器状态：
- **ESTABLISHED**:
   - 连接已建立，服务器可以开始发送和接收数据。
- **CLOSE-WAIT**:
   - 服务器收到了客户端的FIN包，并已发送ACK包，但还没有发送自己的FIN包。
- **LAST-ACK**:
   - 服务器发送了FIN包，等待客户端的最终ACK包。
- **CLOSED**:
   - 在收到客户端的ACK包后，服务器状态从LAST-ACK变为CLOSED状态。

### 3. 第二次挥手和第三次挥手都是服务器发送，为什么不合并？三次握手就是合并后的

- **立刻确认收到客户端的终止请求**：当服务器收到客户端的FIN包时，它需要立即确认这个包，即使它还没有准备好关闭连接。这个ACK包告诉客户端，“我已经收到了你的终止请求”。
- **半关闭状态**：此时，服务器可能还有数据要发送给客户端，因此它不会立即发送FIN包。这种状态称为半关闭（half-close），即客户端不再发送数据，但服务器还可以发送数据。

与三次握手的对比：
- 在三次握手过程中，SYN和ACK包是合并的，因为它们都是连接建立的一部分，并且在这个阶段，双方都没有数据要发送。客户端发送SYN，服务器响应SYN+ACK，这是一种同步操作，双方都准备好了进行数据传输。
- 在四次挥手过程中，由于涉及到数据的发送和处理，所以ACK和FIN包是分开的，分别处理连接的半关闭和完全关闭。

### 4. TIME-WAIT状态为什么需要2MSL时间？

如果客户端在关闭连接后立即重新连接到服务器，并且使用了相同的端口，那么延迟到达的数据包可能会被错误地认为是属于新连接的数据，从而引起混淆。2MSL的等待时间减少了这种情况发生的可能性。

### 5. 虽然TIME-WAIT状态对于单个连接来说是必要的，但如果服务器需要处理大量的短连接，TIME-WAIT状态可能会导致资源（如端口）被长时间占用，从而影响服务器的性能。如何解决这个问题？

#### 端口重用技术

端口重用技术允许在TCP连接的TIME-WAIT状态结束后，快速重用之前用于该连接的端口。这样做的目的是减少因为大量短连接造成的TIME-WAIT状态累积，从而避免端口资源的长时间占用。以下是一些实现端口重用的技术：
1. **SO_REUSEADDR socket选项**：
   - 在Linux和其他类Unix操作系统中，可以通过设置SO_REUSEADDR选项来允许在TIME-WAIT状态结束后立即重用端口。
   - 这个选项允许服务器绑定到处于TIME-WAIT状态的端口，只要新的连接的四元组（源IP地址、源端口、目的IP地址、目的端口）与之前的连接不同。
2. **TCP快速回收（TCP Fast Recycling）**：
   - 这个技术允许在连接进入TIME-WAIT状态后，更快地回收连接资源。
   - 它通过减少TIME-WAIT状态的持续时间来实现，但这可能会增加网络中旧报文段干扰新连接的风险。

#### 其他优化措施：

1. **调整TCP栈参数**：
   - 可以调整TCP栈的参数，比如`tcp_max_tw_buckets`，来限制系统可以同时处理的TIME-WAIT状态的连接数量。
2. **使用长连接**：
   - 对于频繁交互的应用，可以使用长连接（持久连接）来减少连接的建立和终止次数，从而减少TIME-WAIT状态的出现。
3. **客户端端口范围调整**：
   - 增大客户端使用的端口范围，减少因为端口耗尽而导致的TIME-WAIT状态问题。
4. **负载均衡**：
   - 使用负载均衡器可以将连接分散到多个服务器上，从而减少单个服务器上的TIME-WAIT状态连接数量。
5. **TIME-WAIT状态超时时间优化**：
   - 根据网络环境和应用需求，适当调整TIME-WAIT状态的持续时间。
6. **使用代理服务器**：
   - 通过代理服务器来管理连接，代理服务器可以处理大量的连接和重用端口，从而减轻后端服务器的负担。

### 4. 四次挥手过程中的丢包处理

- **FIN包丢失**：发送方在发送FIN包后，如果没有收到对方的ACK响应，会认为该FIN包可能丢失，因此会重发FIN包。如果重传次数达到限制，连接可能会被异常关闭。
- **ACK包丢失**：接收方在发送ACK包后，如果发送方没有收到这个ACK包，发送方会重发FIN包。接收方在等待一段时间后，如果没有收到预期的下一个包（例如，客户端在发送ACK后服务器等待这个ACK包），它也会重发ACK包。

在四次挥手过程中，如果发生丢包，TCP的可靠性机制会尝试通过重传来恢复连接的关闭过程。但是，如果长时间没有收到响应，最终会导致连接超时关闭。另外，由于TCP连接是全双工的，所以在关闭连接时，每一方向都需要单独进行挥手操作，这意味着每个方向的关闭过程都可能遇到上述丢包情况。


## TCP如何保证 不出错 不重复 不失序 不丢失

### 原因
1. 物理干扰导致bit翻转
2. 当网络延迟较高时，接收端可能没有及时确认接收到的数据包，导致发送端重发数据包。
3. 数据传输路径不同
4. 当网络拥塞严重时，网络设备的缓冲区可能会满，导致新的数据包被丢弃。

### 解决方案
1. TCP头部包含一个校验和字段，用于检测数据在传输过程中的任何错误。如果接收方检测到校验和错误，会丢弃这个数据包，并等待发送方重传。
2. TCP头部包含一个序列号，接收方通过检查序列号来识别重复的数据段。如果接收到了已经确认过的数据，会丢弃重复的数据段。
3. 接收方可以根据序列号对收到的数据进行排序，以确保数据的正确顺序。
4. 当发送方没有在指定的时间（重传时间，必须大于RTT）内收到确认应答，会认为数据包已经丢失或出错，会重新发送数据。

## 拥塞窗口

拥塞窗口（Congestion Window，简称cwnd）是TCP协议中的一个概念，它用于控制发送方在网络上发送数据包的速率，以避免网络拥塞。拥塞窗口的大小决定了在没有收到确认应答（ACK）之前，发送方可以发送的数据量。

以下是拥塞窗口的几个关键点：
1. **定义**：
   - 拥塞窗口是发送方维护的一个变量，它用来限制在收到确认应答之前可以发送的数据量（以字节为单位）。
2. **与接收窗口的关系**：
   - TCP发送方实际发送的数据量受限于拥塞窗口（cwnd）和接收窗口（rwnd，即接收方通告的窗口大小，即ACK中的窗口大小）中的较小值。也就是说，发送方可以发送的数据量是`Min(cwnd, rwnd)`。
3. **拥塞控制**：
   - 拥塞窗口是TCP拥塞控制算法中的一个核心参数。通过调整拥塞窗口的大小，TCP可以控制发送速率，以响应网络拥塞的迹象，如数据包丢失或延迟增加。
4. **调整机制**：
   - 在TCP连接的初始阶段，通常会使用慢启动算法来增加拥塞窗口的大小。
   - 当网络拥塞被检测到时（例如，通过丢包事件），拥塞窗口会被减小，以减少发送速率，避免进一步的网络拥塞。
5. **拥塞窗口与传输速率**：
   - 拥塞窗口的大小直接影响TCP连接的传输速率。拥塞窗口越大，在理想条件下，TCP连接的传输速率越高。
6. **算法影响**：
   - 不同的TCP拥塞控制算法（如慢启动、拥塞避免、快速重传和快速恢复）会以不同的方式调整拥塞窗口的大小。

### 1. TCP的拥塞控制算法，如慢启动，拥塞避免，快速重传和快速恢复

TCP的拥塞控制算法是一系列用于网络拥塞管理的机制，目的是为了防止过多的数据包被发送到网络上，从而导致网络拥塞和性能下降。以下是四种主要的TCP拥塞控制算法：
1. **慢启动（Slow Start）**：
   - 当一个TCP连接开始时，拥塞窗口（cwnd）通常设置为一个最大段大小（MSS）。
   - 在慢启动阶段，每收到一个确认应答（ACK），拥塞窗口就增加一个MSS，这意味着每经过一个往返时间（RTT），拥塞窗口的大小就会翻倍。
   - 这种指数增长持续到达到一个阈值（ssthresh，通常设置为慢启动阈值），之后进入拥塞避免阶段。
   - 慢启动的目的是逐渐探测网络的容量，以避免一开始就发送过多的数据包。
2. **拥塞避免（Congestion Avoidance）**：
   - 在拥塞避免阶段，每经过一个RTT，拥塞窗口只增加1个MSS，而不是像慢启动那样翻倍，这导致cwnd的增长速率变为线性。
   - 这种方法使得拥塞窗口的增长速度减慢，从而避免网络拥塞。
   - 如果网络发生拥塞（例如，检测到丢包），ssthresh会被设置为当前拥塞窗口的一半，并且拥塞窗口会被重置为1个MSS，重新开始慢启动过程。
3. **快速重传（Fast Retransmit）**：
   - 当接收方发现丢包时，它会继续发送重复的ACK，而不是等待下一个期望的序列号。
   - 当发送方收到三个重复的ACK时，它会立即重传丢失的数据包，而不是等待重传计时器超时。
   - 这种机制减少了因等待超时而导致的延迟。
4. **快速恢复（Fast Recovery）**：
   - 在执行快速重传后，发送方不会立即进入慢启动阶段，而是进入快速恢复阶段。
   - 在快速恢复阶段，拥塞窗口被设置为ssthresh加上3个MSS（因为已经收到了三个重复的ACK），然后开始线性增加拥塞窗口。
   - 快速恢复的目的是在检测到少量丢包时，避免不必要的慢启动，从而更快地恢复传输速率。


### 2. 如果网络层的mtu是1500个字节，但是udp一个包最大可以有64k字节。如果这个udp包不分片，是不是就不能通过网络传输？

如果UDP数据包的大小超过了网络层的MTU，那么：
- 如果启用了**IP分片**，IP层会将这个大的UDP数据包分片成多个小于或等于MTU大小的片段，然后这些片段可以被独立地发送和接收。
- 如果没有启用IP分片（例如，在发送端设置了“不要分片”DF标志），那么当数据包大小超过MTU时，它将被网络层丢弃，并发送一个ICMP（Internet Control Message Protocol）错误消息“数据包太大”给发送端。

IP分片是IP层的一个功能，它允许将大的数据包分成更小的片段，以便在网络中传输。这个过程通常发生在以下情况下：
1. **发送端**：当一个主机准备发送一个数据包，而这个数据包的大小超过了下一跳网络的MTU（最大传输单元）时，IP层会自动将这个数据包分成多个小的片段。每个片段都将包含原始IP头部的一部分加上数据包的一部分。
2. **传输过程**：每个分片作为独立的IP数据包在网络中传输。它们可能会经过不同的路径到达目的地。
3. **接收端**：在接收端，IP层会负责将这些分片重新组装成原始的数据包。这是通过检查每个分片的IP头部中的片段信息来完成的，这些信息包括片段偏移量、更多片段（MF）标志以及标识字段。

以下是分片和重组的详细步骤：
- **分片**：
  - 原始数据包的IP头部会被复制到每个分片中。
  - 每个分片会有自己的IP头部，其中包含片段偏移量（表明该片段在原始数据包中的位置）和MF标志（表明是否还有后续分片）。
  - 除了最后一个分片外，其他分片的大小通常是MTU减去IP头部长度的结果。
- **重组**：
  - 接收端的IP层会检查到达的分片，并根据IP头部中的信息将它们重新组装成原始的数据包。
  - 为了重组，所有分片必须到达接收端，并且按照正确的顺序排列。
  - 一旦所有分片都到达，并且按照偏移量正确组装，原始的数据包就会被传递给上层协议（如UDP或TCP）进行处理。

需要注意的是，虽然IP层负责分片和重组，但这并不意味着这个过程总是高效或可靠的。如前所述，分片可能会带来一些问题，包括分片丢失、重组错误、性能下降等。因此，在设计网络应用程序时，最好尽量避免需要IP分片的情况。

## TCP窗口糊涂症

持续小包，导致TCP窗口大小调整出现异常，从而影响TCP性能的问题。

## TCP有哪些优化技术？
TCP优化技术旨在提高网络传输的效率、稳定性和性能。以下是一些常见的TCP优化技术：
1. **窗口缩放（Window Scaling）**：
   - 通过增加TCP窗口大小来提高吞吐量，适用于高延迟和高带宽的网络环境。
2. **选择性确认（Selective Acknowledgment, SACK）**：
   - 允许接收方明确告知发送方哪些数据已经被接收，哪些需要重传，从而提高丢包恢复的效率。
3. **快速重传和快速恢复（Fast Retransmit and Fast Recovery）**：
   - 当发送方连续收到三个重复的ACK时，发送方不需要等待重传计时器到期，立即重传丢失的数据包。
   - 在某些情况下，发送方可以跳过慢启动阶段，直接进入拥塞避免阶段。
4. **拥塞控制算法**：
   - **慢启动（Slow Start）**：在连接开始时逐渐增加发送窗口大小，以避免网络拥塞。
   - **拥塞避免（Congestion Avoidance）**：在达到一定的窗口大小时，线性增加窗口大小，而不是指数增加。
   - **BIC（Binary Increase Congestion Control）**、**CUBIC（Congestion Avoidance and Control）**：这些是现代TCP实现中常用的拥塞控制算法，用于在高带宽和高延迟网络中提高性能。
5. **延迟ACK与Nagle算法的配合**：
   - 延迟确认可以减少ACK的数量：
      - 接收方在收到数据包后并不立即发送确认（ACK），而是等待一小段时间（通常是几十到几百毫秒），以便在此期间能够将其他需要发送的数据或控制信息（如窗口大小更新）与ACK一起发送，从而减少需要发送的TCP段的数量，提高网络效率。
   - 而Nagle算法可以减少小数据包的发送，当发送方有多个小数据包需要发送时，算法会延迟发送这些小数据包，算法规则：
      - 如果包长度达到MSS（最大段大小），或者包含了FIN，则立即发送。
      - 如果之前发送的数据包的ACK尚未返回，则等待直到ACK返回再发送。
6. **TCP timestamps**：
   - 时间戳用于测量RTT（往返时间），帮助TCP更好地处理重传计时器，并且可以用于防止序列号回绕问题。
7. **TCP长连接**：
   - 长连接可以减少建立和关闭连接的开销，适用于需要频繁通信的应用。
8. **TCP连接复用**：
   - 通过复用现有的TCP连接来减少建立新连接的开销，如HTTP/1.1中的持久连接。
9. **TCP splicing**：
   - 在某些操作系统中，可以将两个TCP连接的数据流直接拼接起来，无需在应用程序层面进行数据复制。
10. **TFO（TCP Fast Open）**：
    - 允许数据在建立TCP连接的三次握手过程中立即发送，减少了建立连接的延迟。
11. **Proactive Queue Management（PQM）**：
    - 通过在网络设备中实施主动队列管理策略，如RED（Random Early Detection），可以减少网络拥塞和数据包丢失。
12. **ECN（Explicit Congestion Notification）**：
    - 允许网络设备在检测到拥塞时，通过设置IP头部中的ECN位来通知发送方，而不是通过丢包。
