---
sort: 1
---

# 基本概念

内核：指管理和分配计算机资源（即CPU、RAM 和设备）的核心层软件。

## 内核

### 内核的职责

内核所能执行的主要任务如下所示。

- 进程调度

    计算机内均配备有一个或多个 CPU（中央处理单元），以执行程序指令。与其他UNIX 系统一样，Linux 属于抢占式多任务操作系统。“多任务”意指多个进程（即运行中的程序）可同时驻留于内存，且每个进程都能获得对CPU 的使用权。“抢占”则是指一组规则。这组规则控制着哪些进程获得对 CPU 的使用，以及每个进程能使用多长时间，这两者都由内核进程调度程序（而非进程本身）决定。

- 内存管理

    物理内存（RAM）属于有限资源，内核必须以公平、高效地方式在进程间共享这一资源。与大多数现代操作系统一样，Linux也采用了虚拟内存管理机制，这项技术主要具有以下两方面的优势。
   - 进程与进程之间、进程与内核之间彼此隔离，因此一个进程无法读取或修改内核或其他进程的内存内容。
   - 只需将进程的一部分保持在内存中，这不但降低了每个进程对内存的需求量，而且还能在RAM 中同时加载更多的进程。这也大幅提升了如下事件的发生概率：在任一时刻，CPU 都有至少一个进程可以执行，从而使得对 CPU 资源的利用更加充分。

- 提供了文件系统

    内核在磁盘之上提供有文件系统，允许对文件执行创建、获取、更新以及删除等操作。

- 创建和终止进程

    内核可将新程序载入内存，为其提供运行所需的资源（比如，CPU、内存以及对文件的访问等）。这样一个运行中的程序我们称之为“进程”。一旦进程执行完毕，内核还要确保释放其占用资源，以供后续程序重新使用。

- 对设备的访问

    计算机外接设备（鼠标、键盘、磁盘和磁带驱动器等）可实现计算机与外部世界的通信，这一通信机制包括输入、输出或是两者兼而有之。内核既为程序访问设备提供了简化版的标准接口，同时还要仲裁多个进程对每一个设备的访问。

- 联网

    内核以用户进程的名义收发网络消息（数据包）。该任务包括将网络数据包路由至目标系统。

- 提供系统调用应用编程接口（API）

    进程可利用内核入口点（也称为系统调用）请求内核去执行各种任务。

除了上述特性外，一般而言，诸如 Linux 之类的多用户操作系统会为每个用户营造一种抽象：虚拟私有计算机（virtual  private  computer）。这就是说，每个用户都可以登录进入系统，独立操作，而与其他用户大致无干。例如，每个用户都有属于自己的磁盘存储空间（主目录）。再者，用户能够运行程序，而每一程序都能从 CPU 资源中“分得一杯羹”，运转于自有的虚拟地址空间中。而且这些程序还能独立访问设备，并通过网络传递信息。内核负责解决（多进程）访问硬件资源时可能引发的冲突，用户和进程对此则往往一无所知。

### 内核态和用户态

现代处理器架构一般允许CPU 至少在两种不同状态下运行，即：用户态和内核态（有时也称之为监管态supervisor mode）。执行硬件指令可使CPU 在两种状态间来回切换。与之对应，可将虚拟内存区域划分为用户空间部分或内核空间部分。在用户态下运行时，CPU 只能访问被标记为用户空间的内存，试图访问属于内核空间的内存会引发硬件
异常。当运行于内核态时，CPU 既能访问用户空间内存，也能访问内核空间内存。

仅当处理器在内核态运行时，才能执行某些特定操作：执行宕机（halt）指令去关闭系统，访问内存管理硬件，以及设备I/O 操作的初始化等。内核作者们利用这一硬件设计，将操作系统置于内核空间。这确保了用户进程既不能访问内核指令和数据结构，也无法执行不利于系统运行的操作。

### 总结

|事件|进程|内核|
|:---|:---|:---|
|进程对 CPU 的占用何时“到期”|x|o|
|哪个进程来使用 CPU,以及以何种顺序|x|o|
|再次获得对CPU 的使用|x|o|
|信号的传递|x|o|
|进程间通信|x|o|
|进程在 RAM 中的位置|x|o|
|进程访问的文件在磁盘驱动器的位置|x|o|
|进程创建出新进程|x|o|
|进程“自行了断”|x|o|
|进程与计算机外接的输入输出设备直接通信|x|o|

内核则是运行系统的中枢所在，对于系统的一切无所不知、无所不能，为系统上所有进程的运行提供便利。由哪个进程来接掌对 CPU 的使用，何时“接任”，“任期”多久，都由内核说了算。在内核维护的数据结构中，包含了与所有正在运行的进程有关的信息。随着进程的创建、状态发生变化或者终结，内核会及时更新这些数据结构。内核所维护的底层数据结构可将程序使用的文件名转换为磁盘的物理位置。此外，每个进程的虚拟内存与计算机物理内存及磁盘交换区之间的映射关系，也在内核维护的数据结构之列。进程间的所有通信都要通过内核提供的通信机制来完成。响应进程发出的请求，内核会创建新的进程，终结现有进程。最后，由内核（特别是设备驱动程序）来执行与输入/输出设备之间的所有直接通信，按需与用户进程交互信息。

后续内容中会出现如下措辞，例如：“某进程可创建另一个进程”、“某进程可创建管道”、“某进程可将数据写入文件”，以及“调用exit()以终止某进程”。请务必牢记，以上所有动作都是由内核来居中“调停”，上面的说法不过是“某进程可以请求内核创建另一个进程”的缩略语，以此类推。


## 文件IO模型

UNIX 系统I/O 模型最为显著的特性之一是其 I/O 通用性概念。也就是说，同一套系统调用（open()、read()、write()、close()等）所执行的 I/O 操作，可施之于所有文件类型，包括设备文件在内。（应用程序发起的 I/O 请求，内核会将其转化为相应的文件系统操作，或者设备驱动程序操作，以此来执行针对目标文件或设备的 I/O 操作。）因此，采用这些系统调用的程序能够处理任何类型的文件。

就本质而言，内核只提供一种文件类型：字节流序列，在处理磁盘文件、磁盘或磁带设备时，可通过lseek()系统调用来随机访问。


**stdio 函数库**

C 编程语言在执行文件I/O 操作时，往往会调用C 语言标准库的I/O 函数。也将这样一组 I/O 函数称为 stdio 函数库，其中包括fopen()、fclose()、scanf()、printf()、fgets()、fputs()等。

stdio 函数位于I/O 系统调用层（open()、close()、read()、write()等）之上。
 
  
## 进程

进程是正在执行的程序实例。执行程序时，内核会将程序代码载入虚拟内存，为程序变量分配空间，建立内核记账（bookkeeping）数据结构，以记录与进程有关的各种信息（比如，进程ID、用户ID、组ID 以及终止状态等）。

在内核看来，进程是一个个实体，内核必须在它们之间共享各种计算机资源。对于像内存这样的受限资源来说，内核一开始会为进程分配一定数量的资源，并在进程的生命周期内，统筹该进程和整个系统对资源的需求，对这一分配进行调整。程序终止时，内核会释放所有此类资源，供其他进程重新使用。其他资源（如 CPU、网络带宽等）都属于可再生资源，但必须在所有进程间平等共享。

### 进程的内存布局

逻辑上将一个进程划分为以下几部分（也称为段）。
- 文本：程序的指令。
- 数据：程序使用的静态变量。
- 堆：程序可从该区域动态分配额外内存。
- 栈：随函数调用、返回而增减的一片内存，用于为局部变量和函数调用链接信息分配存储空间。

### 创建进程和执行程序

进程可使用系统调用 fork()来创建一个新进程。调用 fork()的进程被称为父进程，新创建的进程则被称为子进程。内核通过对父进程的复制来创建子进程。子进程从父进程处继承数据段、栈段以及堆段的副本后，可以修改这些内容，不会影响父进程的“原版”内容。（在内存中被标记为只读的程序文本段则由父、子进程共享。）

然后，子进程要么去执行与父进程共享代码段中的另一组不同函数，或者，更为常见的情况是使用系统调用 execve()去加载并执行一个全新程序。execve()会销毁现有的文本段、数据段、栈段及堆段，并根据新程序的代码，创建新段来替换它们。以 execve()为基础，C 语言库还提供了几个相关函数，接口虽然略有不同，但功能全都相同。以上所有库函数的名称均以字符串“exec”打头，在函数间差异无关宏旨的场合，本书会用符号
exec()作为这些库函数的统称。不过，请读者牢记，实际上根本不存在名为exec()的库函数。一般情况下，书中会使用“执行”一词来指代execve()及其衍生函数所实施的操作。

### 进程ID 和父进程ID

每一进程都有一个唯一的整数型进程标识符（PID）。此外，每一进程还具有一个父进程标识符（PPID）属性，用以标识请求内核创建自己的进程。

### 进程终止和终止状态

可使用以下两种方式之一来终止一个进程：其一，进程可使用_exit()系统调用（或相关的exit()库函数），请求退出；其二，向进程传递信号，将其“杀死”。无论以何种方式退出，进程都会生成“终止状态”，一个非负小整数，可供父进程的 wait()系统调用检测。在调用_exit()的情况下，进程会指明自己的终止状态。若由信号来“杀死”进程，则会根据导致进程“死亡”的信号类型来设置进程的终止状态。（有时会将传递进_exit()的参数称为进程的“退出状态”，以示与终止状态有所不同，后者要么指传递给_exit()的参数值，要么表示“杀死”进程的信号。） 根据惯例，终止状态为0 表示进程“功成身退”，非0 则表示有错误发生。大多数shell会将前一执行程序的终止状态保存于shell 变量$?中。

### 进程的用户和组标识符（凭证）

每个进程都有一组与之相关的用户ID (UID)和组ID (GID)，如下所示。
- 真实用户 ID 和组 ID：用来标识进程所属的用户和组。新进程从其父进程处继承这些ID。登录shell 则会从系统密码文件的相应字段中获取其真实用户ID 和组ID。
- 有效用户 ID 和组 ID：进程在访问受保护资源（比如，文件和进程间通信对象）时，会使用这两个 ID（并结合下述的补充组ID）来确定访问权限。一般情况下，进程的有效 ID 与相应的真实 ID 值相同。正如即将讨论的那样，改变进程的有效ID 实为一种机制，可使进程具有其他用户或组的权限。
- 补充组 ID：用来标识进程所属的额外组。新进程从其父进程处继承补充组 ID。登录shell 则从系统组文件中获取其补充组ID。

### 特权进程

在UNIX 系统上，就传统意义而言，特权进程是指有效用户ID 为0（超级用户）的进程。通常由内核所施加的权限限制对此类进程无效。与之相反，术语“无特权”（或非特权）进程是指由其他用户运行的进程。此类进程的有效用户ID 为非0 值，且必须遵守由内核所强加的权限规则。

### init 进程

系统引导时，内核会创建一个名为init 的特殊进程，即“所有进程之父”，该进程的相应程序文件为/sbin/init。系统的所有进程不是由 init（使用 frok()）“亲自”创建，就是由其后代进程创建。init 进程的进程号总为1，且总是以超级用户权限运行。谁（哪怕是超级用户）都不能“杀死”init 进程，只有关闭系统才能终止该进程。init 的主要任务是创建并监控系统运行所需的一系列进程。

### 资源限制

每个进程都会消耗诸如打开文件、内存以及CPU 时间之类的资源。使用系统调用setrlimit()，进程可为自己消耗的各类资源设定一个上限。此类资源限制的每一项均有两个相关值：软限制（soft limit）限制了进程可以消耗的资源总量，硬限制（hard limit）软限制的调整上限。非特权进程在针对特定资源调整软限制值时，可将其设置为 0 到相应硬限制值之间的任意值，但硬限制值则只能调低，不能调高。由fork()创建的新进程，会继承其父进程对资源限制的设置。

使用ulimit 命令（在C shell 中为limit）可调整shell 的资源限制。shell 为执行命令所创建的子进程会继承上述资源设置。

## 静态库和共享库

静态库是对已编译目标模块的一种结构化整合。主程序会对静态库中隶属于各目标模块的不同函数加以引用。链接器在解析了引用情况后，会从库中抽取所需目标模块的副本，将其复制到最终的可执行文件中，这就是所谓静态链接。这一做法有利于程序的开发和维护，但会引起诸多不便：
- 在不同的可执行文件中，可能都存有相同目标代码的副本，这是对**磁盘空间的浪费**。
- 同理，调用同一库函数的程序，若均以静态链接方式生成，且又于同时加以执行，这会造成**内存浪费**，因为每个程序所调用的函数都各有一份副本驻留在内存中。
- 此外，如果对库函数进行了修改，需要重新加以编译、生成新的静态库，而所有需要调用该函数“更新版”的可执行文件，都必须与新生成的静态库重新链接。

设计共享库的目的是为了解决静态库所存在的问题。

如果将程序链接到共享库，那么链接器就不会把库中的目标模块复制到可执行文件中，而是在可执行文件中写入一条记录，以表明可执行文件在运行时需要使用该共享库。一旦在运行时将可执行文件载入内存，一款名为“动态链接器”的程序会确保将可执行文件所需的动态库找到，并载入内存，随后实施运行时链接，解析可执行文件中的函数调用，将其与共享库中相应的函数定义关联起来。

在运行时，共享库代码在内存中只需保留一份，且可供所有运行中的程序使用。
经过编译处理的函数仅在共享库内保存一份，从而节约了磁盘空间。
另外，这一设计还能确保各类程序及时使用到函数的最新版本，只需将带有函数新定义的共享库重新编译即可，程序会在下次执行时自动使用新函数。

## 进程间通信及同步

Linux 系统上有些进程必须相互合作以达成预期目的，因此彼此间需要通信和同步机制。
- 信号（signal），用来表示事件的发生。
- 管道（亦即shell 用户所熟悉的“|”操作符）和FIFO，用于在进程间传递数据。
- 套接字，供同一台主机或是联网的不同主机上所运行的进程之间传递数据。
- 文件锁定，为防止其他进程读取或更新文件内容，允许某进程对文件的部分区域加以锁定。
- 消息队列，用于在进程间交换消息（数据包）。
- 信号量（semaphore），用来同步进程动作。
- 共享内存，允许两个及两个以上进程共享一块内存。当某进程改变了共享内存的内容时，其他所有进程会立即了解到这一变化。

## 信号

尽管上一节将信号视为 IPC 的方法之一，但其在其他方面的广泛应用则更为普遍，因此值得深入讨论。

人们往往将信号称为“软件中断”。进程收到信号，就意味着某一事件或异常情况的发生。信号的类型很多，每一种分别标识不同的事件或情况。采用不同的整数来标识各种信号类型，并以SIGxxxx 形式的符号名加以定义。
内核、其他进程（只要具有相应的权限）或进程自身均可向进程发送信号。例如，发生下列情况之一时，内核可向进程发送信号。
- 用户键入中断字符（通常为Control-C）。
- 进程的子进程之一已经终止。
- 由进程设定的定时器（告警时钟）已经到期。
- 进程尝试访问无效的内存地址。

在shell 中，可使用kill 命令向进程发送信号。在程序内部，系统调用kill()可提供相同的功能。收到信号时，进程会根据信号采取如下动作之一。
- 忽略信号。
- 被信号“杀死”。
- 先挂起，之后再被专用信号唤醒。

就大多数信号类型而言，程序可选择不采取默认的信号动作，而是忽略信号（当信号的默认处理行为并非忽略此信号时，会派上用场）或者建立自己的信号处理器。信号处理器是由程序员定义的函数，会在进程收到信号时自动调用，根据信号的产生条件执行相应动作。信号从产生直至送达进程期间，一直处于挂起状态。通常，系统会在接收进程下次获得调度时，将处于挂起状态的信号同时送达。如果接收进程正在运行，则会立即将信号送达。
然而，程序可以将信号纳入所谓“信号屏蔽”1 以求阻塞该信号。如果产生的信号处于“信号屏蔽”之列，那么此信号将一直保持挂起状态，直至解除对该信号的阻塞。（亦即从信号屏蔽中移除。）

## 线程

在现代 UNIX 实现中，每个进程都可执行多个线程。可将线程想象为共享同一虚拟内存及一干其他属性的进程。每个线程都会执行相同的程序代码，共享同一数据区域和堆。可是，每个线程都拥有属于自己的栈，用来装载本地变量和函数调用链接信息。

线程之间可通过共享的全局变量进行通信。借助于线程 API 所提供的条件变量和互斥机制，进程所属的线程之间得以相互通信并同步行为—尤其是在对共享变量的使用方面。此外，利用 IPC 和同步机制，线程间也能彼此通信。

线程的主要优点在于协同线程之间的数据共享（通过全局变量）更为容易，而且就某些算法而论，以多线程来实现比之以多进程实现要更加自然。再者，显而易见，多线程应用能从多处理器硬件的并行处理中获益匪浅。

