---
sort: 12
---

# 进程状态

| 状态 | 描述 | 特点 |
|---|---|---|
| 新建状态（New State） | 操作系统正在创建进程（或线程），为其分配必要的资源            | 进程（或线程）尚未完全初始化，还不能执行                    |
| 就绪状态（Ready State） | 进程（或线程）已经准备好执行，等待CPU时间进行调度            | 进程（或线程）在就绪队列中，等待被分配CPU                    |
| 运行状态（Running State） | 进程（或线程）正在使用CPU执行指令                            | 进程（或线程）的指令正在被处理，进行实际的计算或操作            |
| 等待状态（Waiting State） | 进程（或线程）因等待某个事件（如I/O操作、信号量等）而暂停执行| 进程（或线程）不占用CPU，但保持对已分配资源的控制              |
| 终止状态（Terminated State） | 进程（或线程）已完成执行或被操作系统终止                    | 进程（或线程）不再执行任何操作，等待操作系统进行清理            |
| 挂起就绪状态（Suspended Ready State） | 进程（或线程）已准备好执行，但暂时被挂起，不会立即执行    | 进程（或线程）在就绪队列中，但需要某种外部干预才能恢复执行    |
| 挂起等待状态（Suspended Waiting State） | 进程（或线程）正在等待某个事件的发生，同时也被挂起      | 进程（或线程）既不执行也不需要CPU，直到等待的事件发生或挂起状态被解除|

## 线程共有 VS 线程独占

线程共有
- 进程ID（process ID）和父进程ID
- 进程组ID 与会话ID（session ID）
- 控制终端
- 进程凭证（process credential）（用户ID 和组ID  ）
- 打开的文件描述符
- 由fcntl()创建的记录锁（record lock）
- 信号（signal）处置
- 文件系统的相关信息：文件权限掩码（umask）、当前工作目录和根目录
- 间隔定时器（setitimer()）和POSIX 定时器（timer_create()） 
- 系统V（system V）信号量撤销（undo，semadj）值
- 资源限制（resource limit）
- CPU 时间消耗（由times()返回）
- 资源消耗（由getrusage()返回）
- nice 值（由setpriority()和nice()设置）

线程独占
- 线程ID（thread ID）
- 信号掩码（signal mask）
- 线程特有数据
- 备选信号栈（sigaltstack()）
- errno 变量
- 浮点型（floating-point）环境（见fenv(3)）
- 实时调度策略（real-time scheduling policy）和优先级
- CPU 亲和力（affinity，Linux 所特有）
- 能力（capability，Linux 所特有）
- 栈，本地变量和函数的调用链接（linkage）信息。

## 线程通信

同一程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括数据区、堆区，因此可以以此通信。

线程提供的强大共享是有代价的。多线程应用程序必须使用互斥量和条件变量等同步原语来协调对共享变量的访问。互斥量提供了对共享变量的独占式访问。条件变量允许一个或多个线程等候通知：其他线程改变了共享变量的状态。

### 互斥量

互斥量防止多个线程同时访问同一共享变量。

互斥量类型
- PTHREAD_MUTEX_NORMAL
- PTHREAD_MUTEX_ERRORCHECK：对此类互斥量的所有操作都会执行错误检查。
- PTHREAD_MUTEX_RECURSIVE：递归互斥量维护有一个锁计数器。当线程第1次取得互斥量时，会将锁计数器置1。后续由同一线程执行的每次加锁操作会递增锁计数器的数值，而解锁操作则递减计数器计数。只有当锁计数器值降至0时，才会释放（release，亦即可为其他线程所用）该互斥量。解锁时如目标互斥量处于未锁定状态，或是已由其他线程锁定，操作都会失败。

### 死锁

产生死锁的原因：
- 因为系统资源不足。
- 进程运行推进的顺序不合适。
- 资源分配不当等。

产生死锁的四个必要条件：
- 互斥条件：一个资源每次只能被一个进程使用。
- 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
- 不剥夺条件:进程已获得的资源，在未使用完之前，不能强行剥夺。
- 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

只要上述条件之一不满足，就不会发生死锁。

避免死锁的方法
- 破坏请求和保持条件：为资源分配一个层次结构，要求线程按照资源层次的顺序申请资源。
     - 例如，规定互斥锁`mutex1`的层次低于`mutex2`，那么所有线程在申请资源时，必须先申请`mutex1`，然后才能申请`mutex2`。
- 破坏不可剥夺条件：当线程请求资源时，可以设置一个超时时间。如果在超时时间内没有获取到资源，线程就放弃当前的请求，释放已经持有的资源，然后可以选择稍后重试或者采取其他策略。
   - 例如，使用`pthread_mutex_timedlock`函数来获取互斥锁，它可以设置一个等待的超时时间。如果在这个时间内没有获取到锁，函数就返回一个错误码，线程可以根据这个错误码来决定是继续等待还是放弃并采取其他操作。
- 破坏循环等待条件
   - 方法一：资源排序
     - 对所有的资源进行排序，每个线程在请求资源时，必须按照资源的序号从小到大的顺序进行申请。
     - 比如，有资源R1、R2、R3，它们的序号分别为1、2、3。所有线程在需要访问这些资源时，必须先申请序号为1的资源R1，然后才能申请序号为2的资源R2，以此类推。这样就可以避免出现线程T1等待线程T2持有的资源，而线程T2又等待线程T1持有的资源这种循环等待的情况。
   - 方法二：资源分配图算法（银行家算法的扩展）
     - 可以构建一个资源分配图，图中的节点表示线程和资源。线程节点到资源节点的边表示线程请求资源，资源节点到线程节点的边表示资源已经分配给线程。通过检测资源分配图是否存在环来判断是否可能出现死锁。
     - 如果检测到环，系统可以采取相应的措施，如暂时阻止某些线程请求资源，或者调整资源分配策略，直到图中不再存在环。这种方法相对复杂，但是可以有效地避免死锁的发生。

### 条件变量

条件变量允许一个线程就某个共享变量（或其他共享资源）的状态变化通知其他线程，并让其他线程等待（堵塞于）这一通知。

函数pthread_cond_signal()和pthread_cond_broadcast()均可针对由参数cond 所指定的条件变量而发送信号。pthread_cond_wait()函数将阻塞一线程，直至收到条件变量 cond 的通知。pthread_cond_signal()函数只保证唤醒至少一条遭到阻塞的线程，而pthread_cond_broadcast()则会唤醒所有遭阻塞的线程。

- 当所有等待线程都在执行完全相同的任务。函数pthread_cond_signal()会比pthread_cond_broadcast()更具效率，因为这可以避免发生如下情况。 
    1. 同时唤醒所有等待线程。 
    2. 某一线程首先获得调度。此线程检查了共享变量的状态（在相关互斥量的保护之下），发现还有任务需要完成。该线程执行了所需工作，并改变共享变量状态，以表明任务完成，最后释放对相关互斥量的锁定。 
    3. 剩余的每个线程轮流锁定互斥量并检测共享变量的状态。不过，由于第一个线程所做的工作，余下的线程发现无事可做，随即解锁互斥量转而休眠（即再次调用 pthread_cond_wait()）
- 函数pthread_cond_broadcast()所处理的情况是：处于等待状态的所有线程执行的任务不同（即各线程关联于条件变量的判定条件不同）

条件变量与互斥量之间存在着天然的关联关系。 
1. 线程在准备检查共享变量状态时锁定互斥量。 
2. 检查共享变量的状态。 
3. 如果共享变量未处于预期状态，线程应在等待条件变量并进入休眠前解锁互斥量（以便其他线程能访问该共享变量）。 
4. 当线程因为条件变量的通知而被再度唤醒时，必须对互斥量再次加锁，因为在典型情况下，线程会立即访问共享变量。

函数pthread_cond_wait()会自动执行最后两步中对互斥量的解锁和加锁动作。

#### 条件变量唤醒

```c
pthread_mutex_t mutex;
pthread_cond_t cond;
int shared_variable = 0;

void* thread_consumer(void* arg) {
    pthread_mutex_lock(&mutex);
    while (shared_variable == 0) // no if(shared_variable == 0)
    {
        pthread_cond_wait(&cond, &mutex);
    }
    while (shared_variable > 0)
    {
        shared_variable--; // consuming
    }
    pthread_mutex_unlock(&mutex);
    return NULL;
}
```
在使用条件变量时，使用`while`循环而不是`if`语句来检查条件是为了防止:
- 其他线程可能会率先醒来
- 虚假唤醒

- 当使用`while`循环时，线程每次被唤醒后都会重新检查条件。只有当条件真正满足时，线程才会继续执行后续的代码。

## 线程安全函数

若一函数可由多个线程同时安全调用，则称之为线程安全函数。方法：
1. 函数内不使用共享变量
    1. 使用栈
    2. 使用线程特有数据
    3. 使用线程局部存储：__thread buf[100];但凡带有这种说明符的变量，每个线程都拥有一份对变量的拷贝。线程局部存储中的变量将一直存在，直至线程终止，届时会自动释放这一存储。
    
2. 使用共享变量：利用互斥量确保同时仅有一个线程访问共享资源