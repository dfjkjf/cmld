---
sort: 13
---

# 堆

- 栈是一种后进先出（Last In First Out, LIFO）的数据结构
- 适合回溯


## 1. 数组中的第K个最大元素

在整数数组 `nums` 中找到第 `k` 个最大的元素。请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

**示例：**
```
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
```
### 思路

#### 方法一：排序
最直接的方法是先对数组进行排序，然后直接取倒数第 `k` 个元素。
1. 对数组进行降序排序。
2. 返回第 `k` 个元素。

#### 方法二：最小堆
使用最小堆来维护当前最大的 `k` 个元素。
1. 构建一个大小为 `k` 的最小堆。
2. 遍历数组，对于每个元素：
   - 如果堆的大小小于 `k`，直接将元素加入堆。
   - 如果堆的大小等于 `k`，且当前元素大于堆顶元素，则弹出堆顶元素，将当前元素加入堆。
3. 堆顶元素即为第 `k` 个最大元素。

#### 方法三：快速选择算法
基于快速排序的选择算法，可以在线性时间内找到第 `k` 个最大元素。
1. 选择一个枢纽元素进行分区。
2. 调整枢纽元素的位置，使得左侧元素都大于枢纽，右侧元素都小于枢纽。
3. 如果枢纽的位置正好是 `k-1`，则找到了第 `k` 个最大元素。
4. 否则，根据枢纽的位置递归地在左侧或右侧子数组中继续查找。

下面是使用快速选择算法的C++代码实现：
```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        int left = 0, right = nums.size() - 1;
        int target = nums.size() - k;
        while (true) {
            int idx = partition(nums, left, right);
            if (idx == target) {
                return nums[idx];
            } else if (idx < target) {
                left = idx + 1;
            } else {
                right = idx - 1;
            }
        }
    }
    int partition(vector<int>& nums, int left, int right) {
        int pivot = nums[left];
        int l = left + 1, r = right;
        while (l <= r) {
            if (nums[l] < pivot && nums[r] > pivot) {
                swap(nums[l++], nums[r--]);
            }
            if (nums[l] >= pivot) l++;
            if (nums[r] <= pivot) r--;
        }
        swap(nums[left], nums[r]);
        return r;
    }
};
```

## 155. 前K个高频元素

给定一个非空的整数数组，返回其中出现频率前 K 高的元素。

**示例：**
```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

### 思路

#### 方法一：哈希表 + 排序
1. 使用哈希表统计每个元素出现的频率。
2. 将哈希表中的键值对按值（频率）降序排序。
3. 取排序后前 K 个元素的键（原数组中的元素）。

#### 方法二：哈希表 + 最小堆
1. 使用哈希表统计每个元素出现的频率。
2. 使用一个大小为 K 的最小堆来维护频率最高的 K 个元素。
3. 遍历哈希表，对于每个元素，如果堆的大小小于 K，直接加入堆；如果堆的大小等于 K，且当前元素的频率大于堆顶元素的频率，则弹出堆顶元素，将当前元素加入堆。
4. 堆中的元素即为前 K 个高频元素。

下面是使用哈希表 + 最小堆的 C++ 代码实现：
```cpp
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        // 使用哈希表统计频率
        unordered_map<int, int> freq;
        for (int num : nums) {
            freq[num]++;
        }
        // 定义最小堆的比较函数
        auto comp = [](const pair<int, int>& a, const pair<int, int>& b) {
            return a.second > b.second;
        };
        // 使用最小堆维护前 K 个高频元素
        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comp)> pq(comp);
        for (const auto& kv : freq) {
            pq.push(kv);
            if (pq.size() > k) {
                pq.pop();
            }
        }
        // 从堆中提取结果
        vector<int> result;
        while (!pq.empty()) {
            result.push_back(pq.top().first);
            pq.pop();
        }
        return result;
    }
};
```

