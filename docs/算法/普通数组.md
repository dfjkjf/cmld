---
sort: 5
---

# 普通数组

- 数组的特点是连续，长度确定，滑动窗口多适合

## 1. 最大子数组和

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组**

是数组中的一个连续部分。

**示例 1：**

```
<strong>输入：</strong>nums = [-2,1,-3,4,-1,2,1,-5,4]
<strong>输出：</strong>6
<strong>解释：</strong>连续子数组&nbsp;[4,-1,2,1] 的和最大，为&nbsp;6 。
```

**示例 2：**

```
<strong>输入：</strong>nums = [1]
<strong>输出：</strong>1
```

**示例 3：**

```
<strong>输入：</strong>nums = [5,4,-1,7,8]
<strong>输出：</strong>23
```

**提示：**

-   `1 <= nums.length <= 10<sup>5</sup>`
-   `-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>`

**进阶：** 如果你已经实现复杂度为 `O(n)` 的解法，尝试使用更为精妙的 **分治法** 求解。


### 思路


## 2. 合并区间

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]` 。请你合并所有重叠的区间，并返回 _一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间_ 。

**示例 1：**

```
<strong>输入：</strong>intervals = [[1,3],[2,6],[8,10],[15,18]]
<strong>输出：</strong>[[1,6],[8,10],[15,18]]
<strong>解释：</strong>区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**示例 2：**

```
<strong>输入：</strong>intervals = [[1,4],[4,5]]
<strong>输出：</strong>[[1,5]]
<strong>解释：</strong>区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

**提示：**

-   `1 <= intervals.length <= 10<sup>4</sup>`
-   `intervals[i].length == 2`
-   `0 <= start<sub>i</sub> <= end<sub>i</sub> <= 10<sup>4</sup>`

### 思路

- 数组长n，滑动窗口长k。暴力遍历的时间复杂度是O((n-k)*k)
- 利用现有的数据结构优化滑动窗口内的排序。

1. 暴力法

```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> result;
        for (int i = 0; i <= nums.size() - k; i++) {
            int max_val = nums[i];
            for (int j = i; j < i + k; j++) {
                max_val = max(max_val, nums[j]);
            }
            result.push_back(max_val);
        }
        return result;
    }
};
```

2. 双端递减序列：每次值排序入队，队列存储下标而非值。

```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> result;
        deque<int> dq; // 双端队列，存储下标

        for (int i = 0; i < nums.size(); i++) {
            // 窗口的起始下标是 i - k + 1
            while (!dq.empty() && dq.front() < i - k + 1) {
                dq.pop_front();
            }
            // 保持队列递减：先把小于它的都丢掉
            while (!dq.empty() && nums[dq.back()] < nums[i]) {
                dq.pop_back();
            }
            // 它将以最小者的姿态加入队列
            dq.push_back(i);
            // 当窗口起始下标是 i - k + 1 时，记录最大值
            if (i - k + 1 >= 0) {
                result.push_back(nums[dq.front()]);
            }
        }
        return result;
    }
};
```

3. 优先队列：优先队列默认递减排序

```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        priority_queue<pair<int, int>> q;
        for (int i = 0; i < k; ++i) {
            q.emplace(nums[i], i);
        }
        vector<int> res = {q.top().first};
        for (int i = k; i < nums.size(); ++i) {
            // 插入队列，默认递减排序
            q.emplace(nums[i], i);
            // 排除下标不在范围内的所有大值，反正新加入的在范围内
            while (q.top().second < i - k + 1) {
                q.pop();
            }
            res.emplace_back(q.top().first);
        }
        return res;
    }
};
```

## 3. 最小覆盖子串

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意：**

-   对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
-   如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

**示例 1：**

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。
```

**示例 2：**

```
输入：s = "a", t = "a"
输出："a"
解释：整个字符串 s 是最小覆盖子串。
```

**示例 3:**

```
输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。
```

**提示：**

-   `m == s.length`
-   `n == t.length`
-   `1 <= m, n <= 10^5`
-   `s` 和 `t` 由英文字母组成

**进阶：**你能设计一个在 `o(m+n)` 时间内解决此问题的算法吗？

### 思路

一个长度为 n 的字符串有 n*(n+1)/2 个子串。这是因为子串可以从字符串的任意位置开始，到任意位置结束。具体来说：
- 从第一个字符开始的子串有 n 个（包括只有一个字符的子串）。
- 从第二个字符开始的子串有 n-1 个。
- ...
- 从第 n 个字符开始的子串有 1 个（即该字符本身）。

因此，子串的总数是：1 + 2 + 3 + ... + n = n*(n+1)/2

- 使用滑动窗口，左右边界初始都为0，右边界向右移动确定是否包含子串
- 确定包含子串后，右边界暂停，左边界右移尝试缩小窗口，直到不包含子串
- 记录左边界最小包含坐标，左边界暂停，向右移动右边界再次查找子串，直到右边界到底

