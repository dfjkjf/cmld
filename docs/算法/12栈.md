---
sort: 12
---

# 栈

- 栈是一种后进先出（Last In First Out, LIFO）的数据结构
- 适合回溯


## 1. 有效的括号

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s`，判断字符串是否有效。

有效字符串需满足：
1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。

**示例：**
```
输入: "()"
输出: true
输入: "()[]{}"
输出: true
输入: "(]"
输出: false
输入: "([)]"
输出: false
输入: "{[]}"
输出: true
```
### 思路

1. 初始化一个空栈。
2. 遍历字符串中的每一个字符。
3. 对于每一个字符：
   - 如果它是左括号（'(', '{', '['），将其推入栈中。
   - 如果它是右括号（')', '}', ']'），检查栈顶元素是否为对应的左括号：
     - 如果是，则将栈顶元素弹出。
     - 如果不是，或者栈为空，则返回 `false`。
4. 遍历完所有字符后，如果栈为空，则所有括号都正确闭合，返回 `true`；否则返回 `false`。

```cpp
bool isValid(string s) {
    stack<char> brackets;
    for (char c : s) {
        switch (c) {
            case '(':
            case '{':
            case '[':
                brackets.push(c);
                break;
            case ')':
                if (brackets.empty() || brackets.top() != '(') return false;
                brackets.pop();
                break;
            case '}':
                if (brackets.empty() || brackets.top() != '{') return false;
                brackets.pop();
                break;
            case ']':
                if (brackets.empty() || brackets.top() != '[') return false;
                brackets.pop();
                break;
        }
    }
    return brackets.empty();
}
```


## 155. 最小栈

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。
- `push(x)` —— 将元素 x 推入栈中。
- `pop()` —— 删除栈顶的元素。
- `top()` —— 获取栈顶元素。
- `getMin()` —— 检索栈中的最小元素。

**示例：**
```
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

### 思路
为了实现常数时间复杂度内检索到最小元素，我们可以使用两个栈：一个栈用来存储所有元素（主栈），另一个栈用来存储当前栈中的最小元素（辅助栈）。
1. 初始化两个栈：`mainStack` 和 `minStack`。
2. 对于 `push` 操作：
   - 将元素推入 `mainStack`。
   - 如果 `minStack` 为空或者 `minStack` 的栈顶元素大于等于当前元素，则将当前元素也推入 `minStack`。
3. 对于 `pop` 操作：
   - 从 `mainStack` 中弹出栈顶元素。
   - 如果弹出的元素等于 `minStack` 的栈顶元素，则也从 `minStack` 中弹出栈顶元素。
4. 对于 `top` 操作：
   - 返回 `mainStack` 的栈顶元素。
5. 对于 `getMin` 操作：
   - 返回 `minStack` 的栈顶元素，即为当前栈中的最小元素。

```cpp
class MinStack {
private:
    stack<int> mainStack;
    stack<int> minStack;
public:
    MinStack() {}
    void push(int x) {
        mainStack.push(x);
        if (minStack.empty() || x <= minStack.top()) {
            minStack.push(x);
        }
    }
    void pop() {
        if (mainStack.top() == minStack.top()) {
            minStack.pop();
        }
        mainStack.pop();
    }
    int top() {
        return mainStack.top();
    }
    int getMin() {
        return minStack.top();
    }
};
```

## 394. 字符串解码

给定一个经过编码的字符串，返回它解码后的字符串。编码规则为：`k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 `k` 次。注意 `k` 保证为正整数。

你可以假设输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

**示例：**
```
输入: s = "3[a]2[bc]"
输出: "aaabcbc"
输入: s = "3[a2[c]]"
输出: "accaccacc"
输入: s = "2[abc]3[cd]ef"
输出: "abcabccdcdcdef"
```

### 思路
这个问题可以通过使用栈来解决。我们需要两个栈：一个用于数字，另一个用于字符。当遇到一个数字时，我们将其压入数字栈；当遇到一个字符（除了']'）时，我们将其压入字符栈。当遇到 ']' 时，我们需要弹出字符栈中的字符，直到遇到 '['，同时计算需要重复的次数（由数字栈的栈顶元素给出），然后将重复后的字符串重新压入字符栈。

1. 初始化两个栈：一个用于数字（`numStack`），另一个用于字符（`strStack`）。
2. 遍历输入字符串 `s`。
3. 对于每个字符：
   - 如果它是数字，将其转换为整数并压入 `numStack`。
   - 如果它是字母或 '['，直接压入 `strStack`。
   - 如果它是 ']'，从 `strStack` 中弹出字符直到遇到 '['，将这些字符组成一个字符串，然后根据 `numStack` 的栈顶元素重复该字符串，最后将重复后的字符串压回 `strStack`。
4. 遍历结束后，`strStack` 中的元素即为解码后的字符串。

```cpp
string decodeString(string s) {
    stack<int> numStack;
    stack<string> strStack;
    string currentStr = "";
    int k = 0;
    for (char ch : s) {
        if (isdigit(ch)) {
            k = k * 10 + (ch - '0');  // 计算数字
        } else if (isalpha(ch)) {
            currentStr += ch;  // 添加字母到当前字符串
        } else if (ch == '[') {
            numStack.push(k);  // 数字入栈
            strStack.push(currentStr);  // 当前字符串入栈
            k = 0;  // 重置数字
            currentStr = "";  // 重置当前字符串
        } else if (ch == ']') {
            int loop = numStack.top();
            numStack.pop();
            string temp = "";
            for (int j = 0; j < loop; j++) {
                temp += currentStr;  // 重复字符串
            }
            currentStr = strStack.top() + temp;
            strStack.pop();
        }
    }
    return currentStr;
}
```
