---
sort: 2
---

# 双指针

- 多是快慢指针

## 1. 移动零

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

**示例 1:**

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**示例 2:**

```
输入: nums = [0]
输出: [0]
```

**提示**:

-   `1 <= nums.length <= 10^4`
-   `-2^31 <= nums[i] <= 2^31 - 1`

### 思路

- 保持非零元素的相对顺序，即只能从头遍历数组，把0元素逐步向后移动。
- 利用冒泡逐渐向后移动0元素比每次0元素后的所有元素向前移动要快。
- 快慢指针遍历，当慢指针为0，快指针不为0时元素交换，直到快指针到底。

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int n = nums.size(), slow = 0, fast = 0;
        while (fast < n)
        {
            if (nums[fast])
            {
                swap(nums[slow], nums[fast]);
                slow++;
            }
            fast++;
        }
    }
};
```

## 2. 盛最多水的容器

给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

**说明：** 你不能倾斜容器。

**示例 1：**

![盛最多水的容器](./imags/盛最多水的容器.jpg)

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为49。
```

**示例 2：**

```
输入：height = [1,1]
输出：1
```

**提示：**

-   `n == height.length`
-   `2 <= n <= 10^5`
-   `0 <= height[i] <= 10^4`

### 思路

- 其实是求最大面积：宽是两值下标差`(r-l)`，高是两值最小`min(height[l], height[r])`
- 以最大宽的面积为基准，缩小宽，比较新旧面积
- 缩小宽要改变短长的

```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        int l = 0, r = height.size()-1;
        int res = 0;
        while (l < r)
        {
            int area = min(height[l], height[r])*(r-l);
            res = max(res, area);
            height[l] <= height[r] ? l++ : r--;
        }
        return res;
    }
};
```

## 3. 三数之和

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。

**注意：** 答案中不可以包含重复的三元组。

**示例 1：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```

**示例 2：**

```
输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。
```

**示例 3：**

```
输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0 。
```

**提示：**

-   `3 <= nums.length <= 3000`
-   `-10^5 <= nums[i] <= 10^5`

### 思路

- 一眼是三重循环，要想办法减少循环。
- 要去重就排除每次循环相同的元素。排序，方便跳过相同元素。
- 将三重循环减少到两重循环，先确定第一个值，再找另两个值，查询另两个利用双边指针向中间移动，直到相遇。
- 移动过程遇相同跳过，直到不同。

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int l, r;
        vector<vector<int> > ans;
        for (int i = 0; i < nums.size() - 2; ++i)
        {
            if (i > 0 && nums[i] == nums[i - 1]) continue; // 跳过重复的元素
            int l = i + 1, r = nums.size() - 1;
            while (l < r)
            {
                int sum = nums[i] + nums[l] + nums[r];
                if (sum == 0)
                {
                    ans.emplace_back({nums[i], nums[l], nums[r]});
                    ++l;
                    --r;
                    /* 可以在找到一个满足条件的三元组后，继续移动指针，直到遇到不同的元素为止 */
                    while (l < r && nums[l] == nums[l - 1]) // 跳过重复的元素
                        ++l;
                    while (l < r && nums[r] == nums[r + 1]) // 跳过重复的元素
                        --r;
                } else if (sum < 0) {
                    ++l;
                } else {
                    --r;
                }
            }
        }
        return ans;
    }
};
```

## 4. 接雨水

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**示例 1：**

![接雨水](./imags/接雨水.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

**示例 2：**

```
输入：height = [4,2,0,3,2,5]
输出：9
```

**提示：**

-   `n == height.length`
-   `1 <= n <= 2 * 10^4`
-   `0 <= height[i] <= 10^5`

### 思路

双指针法
   - 使用两个指针分别从左右两端向中间移动。
   - 同时维护两个变量表示左右两侧的最大高度。
   - 每次移动高度较小的一侧的指针，因为只有高度较小的一侧才有可能形成可以接雨水的凹槽。
   - 在移动过程中，计算当前位置可以接的雨水量，即当前位置左侧和右侧的最大高度中的较小值减去当前位置的高度。

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int left = 0, right = height.size() - 1;
        int leftMax = 0, rightMax = 0;
        int ans = 0;
        while (left < right) {
            if (height[left] < height[right]) {
                if (height[left] >= leftMax) {
                    leftMax = height[left];
                } else {
                    ans += leftMax - height[left];
                }
                left++;
            } else {
                if (height[right] >= rightMax) {
                    rightMax = height[right];
                } else {
                    ans += rightMax - height[right];
                }
                right--;
            }
        }
        return ans;
    }
};
```

**四、代码解释（双指针法）**

1. 初始化两个指针 `left` 和 `right` 分别指向数组的左右两端，初始化 `leftMax` 和 `rightMax` 为 0，表示左右两侧目前的最大高度，初始化 `ans` 为 0 表示总的雨水量。
2. 进入循环，当 `left` 小于 `right` 时进行循环。
   - 如果 `height[left]` 小于 `height[right]`，说明左侧的柱子更矮，此时需要考虑左侧柱子能否接雨水。如果 `height[left]` 大于等于 `leftMax`，说明当前左侧柱子是左侧的最高柱子，更新 `leftMax`。如果 `height[left]` 小于 `leftMax`，说明当前位置可以接雨水，雨水量为 `leftMax - height[left]`，将其累加到 `ans` 中，然后移动 `left` 指针向右一步。
   - 否则，说明右侧的柱子更矮，处理方式与左侧类似，更新 `rightMax`，计算右侧当前位置的雨水量并累加到 `ans` 中，然后移动 `right` 指针向左一步。
3. 循环结束后，返回 `ans` 即为总的雨水量。
