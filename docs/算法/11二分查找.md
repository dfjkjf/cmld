---
sort: 11
---

# 二分查找

- 用于有序集合的查找
- 每次查找范围减半

在二分查找算法中，使用 `while (left < right)` 而不是 `while (left <= right)` 的主要原因是这两种条件循环的逻辑和它们对应的退出条件不同。

### 使用 while (left < right)

当使用 `while (left < right)` 时，循环会在 `left` 和 `right` 相遇之前停止。这意味着在循环结束时，`left` 和 `right` 可能指向同一个元素，也可能 `left` 指向 `right` 的前一个元素。这种情况下，我们需要在循环外单独检查 `left` 或 `right` 是否指向目标值。

在 "34. Find First and Last Position of Element in Sorted Array" 这个问题中，这种做法是有意的，因为我们想要找到目标值的第一个和最后一个位置。在寻找第一个位置时，我们希望 `left` 最终指向第一个出现的 `target`，而在寻找最后一个位置时，我们希望 `right` 最终指向最后一个 `target` 的下一个位置。

### 使用 `while (left <= right)`

如果使用 `while (left <= right)`，循环会在 `left` 等于 `right` 时继续执行，这意味着 `left` 和 `right` 必须指向同一个元素。这种情况下，循环的退出条件通常是 `left` 或 `right` 已经越过了数组的边界，或者找到了目标值。

这种循环条件通常用于标准的二分查找，其中我们只关心是否找到了目标值，而不关心它在数组中的具体位置。

### 为什么在 "34" 题目中使用 `while (left < right)`

在 "34" 题目中，我们需要找到目标值的第一个和最后一个位置，所以我们需要更精确地控制 `left` 和 `right` 的移动：
1. 在寻找第一个位置时，我们希望 `left` 最终停在第一个 `target` 的位置上。如果使用 `while (left <= right)`，我们可能会在 `left` 和 `right` 相等时退出循环，但此时我们还没有确认这个位置是否是 `target`。
2. 在寻找最后一个位置时，我们希望 `right` 最终停在最后一个 `target` 的下一个位置上。如果使用 `while (left <= right)`，我们可能会在 `left` 和 `right` 相等时退出循环，这可能会导致我们无法正确地找到最后一个 `target` 的位置。
因此，使用 `while (left < right)` 允许我们在循环结束后进行一次额外的检查，以确保我们找到了正确的位置，或者确定目标值不存在于数组中。这是处理这类问题的标准做法，可以确保算法的正确性和效率。


## 1. 搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

**示例 1：**

```
<strong>输入：</strong>nums = [1, 3, 5, 6], target = 5
<strong>输出：</strong>2
```

**示例 2：**

```
<strong>输入：</strong>nums = [1, 3, 5, 6], target = 2
<strong>输出：</strong>1
```

### 思路

二分查找的步骤：
1. 初始化两个指针，分别指向数组的开始和结束位置。
2. 在每次循环中，计算中间位置的索引。
3. 比较中间位置的值与目标值：
   - 如果中间位置的值等于目标值，则返回中间位置的索引。
   - 如果中间位置的值小于目标值，则将开始指针移动到中间位置的下一个位置。
   - 如果中间位置的值大于目标值，则将结束指针移动到中间位置的前一个位置。
4. 如果开始指针超过了结束指针，说明目标值不在数组中，此时开始指针的位置即为目标值应该插入的位置。

```cpp
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2; // 防止溢出
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return left; // 如果找不到，left 就是插入的位置
    }
};
```

## 2. 搜索二维数组

编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有以下特性：
- 每行中的整数从左到右按升序排列。
- 每行的第一个整数大于前一行的最后一个整数。

**示例 1：**
```
考虑以下矩阵：
[
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
给定目标值 `target = 3`，返回 `true`。
给定目标值 `target = 13`，返回 `false`。
```

### 思路

通过将二维矩阵视为一个一维有序数组来解决。由于矩阵的每一行都是有序的，并且每一行的第一个元素大于上一行的最后一个元素，我们可以使用两次二分查找来解决这个问题：
1. 第一次二分查找：在矩阵的每一行第一个元素上进行二分查找，以确定目标值可能在哪一行。
2. 第二次二分查找：在确定的行中进行二分查找，以查找目标值是否存在。

```cpp
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        if (matrix.empty() || matrix[0].empty()) return false;
        
        int m = matrix.size();
        int n = matrix[0].size();
        
        // 第一次二分查找，确定行
        int left = 0, right = m - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (matrix[mid][0] <= target && target <= matrix[mid][n-1]) {
                // 第二次二分查找，确定列
                int l = 0, r = n - 1;
                while (l <= r) {
                    int midCol = l + (r - l) / 2;
                    if (matrix[mid][midCol] == target) {
                        return true;
                    } else if (matrix[mid][midCol] < target) {
                        l = midCol + 1;
                    } else {
                        r = midCol - 1;
                    }
                }
                return false;
            } else if (matrix[mid][0] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return false;
    }
};
```

## 3. 在排序数组中查找元素的第一个和最后一个位置

给定一个按照升序排列的整数数组 `nums` 和一个目标值 `target`，找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值，则返回 `[-1, -1]`。
你的算法时间复杂度必须是 O(log n) 级别的。

**示例 1：**
```
输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]
```
**示例 2：**
```
输入: nums = [5,7,7,8,8,10], target = 6
输出: [-1,-1]
```

### 思路

1. 使用二分查找找到目标值 `target` 的第一个位置（即最左边的位置）。
2. 使用二分查找找到目标值 `target` 的最后一个位置（即最右边的位置）。

```cpp
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        vector<int> result = {-1, -1};
        if (nums.empty()) return result;
        // 查找第一个位置
        int left = 0, right = nums.size() - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        if (nums[left] == target) {
            result[0] = left;
        } else {
            return result; // 如果第一个位置都不存在，直接返回 [-1, -1]
        }
        // 查找最后一个位置
        right = nums.size();
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > target) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        result[1] = right - 1; // right 指向的是第一个大于 target 的位置，所以最后一个位置是 right - 1
        return result;
    }
};
```