---
sort: 3
---

# 滑动窗口

- 持续地维护两个边界

## 1. 无重复字符的最长字串

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长**

**子串**

 的长度。

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 <code>"abc"</code>，所以其长度为 3。
```

**示例 2:**

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 <code>"b"</code>，所以其长度为 1。
```

**示例 3:**

```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是&nbsp;<code>"wke"</code>，所以其长度为 3。
&nbsp;    请注意，你的答案必须是 子串 的长度，<code>"pwke"</code>&nbsp;是一个<em>子序列，</em>不是子串。
```

**提示：**

-   `0 <= s.length <= 5 * 10^4`
-   `s` 由英文字母、数字、符号和空格组成


### 思路

- 利用两个指针遍历，其中一个总是+1，并把遇到的元素都加入哈希表，保留哈希表存过的最长子串
- 另一个指针哈希表遇重才+1，并且哈希表去除最先加入的元素，形成快慢指针，当快指针遍历到最右端时结束。

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int res = 0;
        unordered_set<char> hastable;
        for (int l = 0, r = 0; r < s.length(); r++) // 外层循环扩展右边界，内层循环扩展左边界
        {
            while (hastable.contains(s[r])) {
                hastable.erase(s[l]);
                l++;
            }
            hastable.insert(s[r]);
            res = max(res, r - l + 1);
        }
        return res;
    }
};
```

## 2. 找到字符串中所有字母异位词

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。

**示例 1:**

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

 **示例 2:**

```
输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
```

**提示:**

-   `1 <= s.length, p.length <= 3 * 10^4`
-   `s` 和 `p` 仅包含小写字母

### 思路

- 一眼滑动窗口，窗口大小固定
- 双指针从左至右遍历，和目标子串比较，直到右指针到最后一个元素

```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        if (s.length() < p.length()) return {};
        vector<int> res;
         // 窗口边界
        unordered_map<char, int> window; // 窗口哈希表
        unordered_map<char, int> target; // 目标哈希表
        // 初始化窗口哈希表 目标子串哈希表
        for (int i = 0; i < p.size(); ++i) {
            window[s[i]]++;
            target[p[i]]++;
        }
        // 滑动窗口搜索
        for (int l = 0, r = p.size() - 1; r < s.size();) {
            // 哈希表相等则为异位词关系
            if (window == target) {
                res.emplace_back(l);
            }
            // 更新窗口哈希表和窗口边界
            window[s[l++]]--;
            if (window[s[l - 1]] == 0) window.erase(s[l - 1]); // 移除无效的 key
            window[s[++r]]++;
        }

        return res;
    }
};

```
