---
sort: 4
---

# 子串

- 子串的特点是连续，滑动窗口多适合

## 1. 和为K的子数组

给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 _该数组中和为 `k` 的子数组的个数_ 。

子数组是数组中元素的连续非空序列。

**示例 1：**

```
输入：nums = [1,1,1], k = 2
输出：2
```

**示例 2：**

```
输入：nums = [1,2,3], k = 3
输出：2
```

**提示：**

-   `1 <= nums.length <= 2 * 10^4`
-   `-1000 <= nums[i] <= 1000`
-   `-10^7 <= k <= 10^7`

### 思路

- 数组是未排序的，且边界移动条件不明确，不能用滑动窗口
- 子数组是连续的，左右两个边界移动求内部和为k

1. 暴力枚举：使用两个循环来枚举所有可能的子数组。外层循环确定子数组的起始位置，内层循环确定子数组的结束位置。
```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int count = 0;
        for (int start = 0; start < nums.size(); ++start) {
            int sum = 0;
            for (int end = start; end < nums.size(); ++end) {
                sum += nums[end]; // 计算从start到end的子数组和
                if (sum == k) {
                    count++; // 如果子数组和等于K，计数器加一
                }
            }
        }
        return count;
    }
};
```

2. 把两个边界移动变为一个边界移动，从求子数组的和变为求子数组前面数组（从零开始）的和。

```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> mp;
        int count = 0, pre = 0;
        mp[0] = 1; // 有一个虚拟的前缀和为0的子数组，它出现了1次

        for (auto& x : nums) {
            pre += x; // 更新前缀和
            if (mp.contains(pre-k)) {
                count += mp[pre-k];
            }
            // 更新哈希表中当前前缀和出现的次数
            mp[pre]++;
        }

        return count;
    }
};
```

## 2. 滑动窗口最大值

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 _滑动窗口中的最大值_ 。

**示例 1：**

```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

**示例 2：**

```
输入：nums = [1], k = 1
输出：[1]
```

**提示：**

-   `1 <= nums.length <= 10^5`
-   `-10^4 <= nums[i] <= 10^4`
-   `1 <= k <= nums.length`

### 思路

- 数组长n，滑动窗口长k。暴力遍历的时间复杂度是O((n-k)*k)
- 利用现有的数据结构优化滑动窗口内的排序。

1. 暴力法

```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> result;
        for (int i = 0; i <= nums.size() - k; i++) {
            int max_val = nums[i];
            for (int j = i; j < i + k; j++) {
                max_val = max(max_val, nums[j]);
            }
            result.push_back(max_val);
        }
        return result;
    }
};
```

2. 双端递减序列：每次值排序入队，队列存储下标而非值。

```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> result;
        deque<int> dq; // 双端队列，存储下标

        for (int i = 0; i < nums.size(); i++) {
            // 窗口的起始下标是 i - k + 1
            while (!dq.empty() && dq.front() < i - k + 1) {
                dq.pop_front();
            }
            // 保持队列递减：先把小于它的都丢掉
            while (!dq.empty() && nums[dq.back()] < nums[i]) {
                dq.pop_back();
            }
            // 它将以最小者的姿态加入队列
            dq.push_back(i);
            // 当窗口起始下标是 i - k + 1 时，记录最大值
            if (i - k + 1 >= 0) {
                result.push_back(nums[dq.front()]);
            }
        }
        return result;
    }
};
```

3. 优先队列：优先队列默认递减排序

```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        priority_queue<pair<int, int>> q;
        for (int i = 0; i < k; ++i) {
            q.emplace(nums[i], i);
        }
        vector<int> res = {q.top().first};
        for (int i = k; i < nums.size(); ++i) {
            // 插入队列，默认递减排序
            q.emplace(nums[i], i);
            // 排除下标不在范围内的所有大值，反正新加入的在范围内
            while (q.top().second < i - k + 1) {
                q.pop();
            }
            res.emplace_back(q.top().first);
        }
        return res;
    }
};
```

## 3. 最小覆盖子串

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意：**

-   对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
-   如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

**示例 1：**

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。
```

**示例 2：**

```
输入：s = "a", t = "a"
输出："a"
解释：整个字符串 s 是最小覆盖子串。
```

**示例 3:**

```
输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。
```

**提示：**

-   `m == s.length`
-   `n == t.length`
-   `1 <= m, n <= 10^5`
-   `s` 和 `t` 由英文字母组成

**进阶：**你能设计一个在 `o(m+n)` 时间内解决此问题的算法吗？

### 思路

一个长度为 n 的字符串有 n*(n+1)/2 个子串。这是因为子串可以从字符串的任意位置开始，到任意位置结束。具体来说：
- 从第一个字符开始的子串有 n 个（包括只有一个字符的子串）。
- 从第二个字符开始的子串有 n-1 个。
- ...
- 从第 n 个字符开始的子串有 1 个（即该字符本身）。

因此，子串的总数是：1 + 2 + 3 + ... + n = n*(n+1)/2

- 使用滑动窗口，左右边界初始都为0，右边界向右移动确定是否包含子串
- 确定包含子串后，右边界暂停，左边界右移尝试缩小窗口，直到不包含子串
- 记录左边界最小包含坐标，左边界暂停，向右移动右边界再次查找子串，直到右边界到底

