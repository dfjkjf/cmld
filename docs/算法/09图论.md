---
sort: 9
---

# 图论

- 通过有限空间映射无限空间
- 有限空间排序

## 1. 岛屿数量

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

**示例 1：**

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

**示例 2：**

```
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

**提示：**

-   `m == grid.length`
-   `n == grid[i].length`
-   `1 <= m, n <= 300`
-   `grid[i][j]` 的值为 `'0'` 或 `'1'`

### 思路

我们可以使用深度优先搜索（DFS）来解决这个问题。以下是解题步骤：
1. 初始化：遍历网格的每一个元素，当我们遇到一个为’1’的元素时，说明我们找到了一个岛屿的一部分。
2. 深度优先搜索：当我们找到一个’1’时，从这个位置开始进行深度优先搜索，将所有相连的’1’都标记为’0’，这样我们就把整个岛屿都“淹没”了。
3. 计数：每当我们开始一个新的深度优先搜索，就意味着我们找到了一个新的岛屿，因此我们可以增加岛屿的计数。

```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int count = 0;
        for (int i = 0; i < grid.size(); i++) {
            for (int j = 0; j < grid[i].size(); j++) {
                if (grid[i][j] == '1') {
                    dfs(grid, i, j);
                    count++;  // 每次dfs调用代表找到了一个岛屿
                }
            }
        }
        return count;
    }

    void dfs(vector<vector<char>>& grid, int i, int j) {
        // 检查边界条件
        if (i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || grid[i][j] == '0') {
            return;
        }
        grid[i][j] = '0';  // 标记为已访问（或者称为“淹没”岛屿）

        // 递归访问四个方向
        dfs(grid, i - 1, j); // 上
        dfs(grid, i + 1, j); // 下
        dfs(grid, i, j - 1); // 左
        dfs(grid, i, j + 1); // 右
    }
};
```

## 2. 腐烂的橘子

在给定的网格中，每个单元格可以有以下三个值之一：
- 值 0 代表空单元格；
- 值 1 代表新鲜橘子；
- 值 2 代表腐烂的橘子。

每分钟，任何与腐烂橘子（在 4 个方向上）相邻的新鲜橘子都会腐烂。

返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。

**示例 1：**
```
输入：[[2,1,1],[1,1,0],[0,1,1]]
输出：4
```
### 思路
我们可以使用广度优先搜索（BFS）来解决这个问题。以下是解题步骤：
1. **初始化**：首先遍历整个网格，将所有腐烂的橘子放入队列中，并记录新鲜橘子的数量。
2. **广度优先搜索**：使用队列进行层序遍历，每遍历一层，就意味着过去了一分钟。在每一层中，我们将腐烂的橘子相邻的新鲜橘子变成腐烂的橘子，并将它们加入队列。
3. **计数**：每当我们从队列中取出一个腐烂的橘子并使其相邻的新鲜橘子腐烂时，新鲜橘子的数量就会减少。当新鲜橘子的数量变为0时，我们就可以停止搜索。
4. **返回结果**：如果在搜索过程中新鲜橘子的数量变为0，则返回经过的分钟数；如果搜索结束后还有新鲜橘子，则返回-1。

```cpp
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        int fresh = 0; // 新鲜橘子的数量
        queue<pair<int, int>> q; // 用于BFS的队列
        // 初始化队列，并统计新鲜橘子的数量
        for (int i = 0; i < grid.size(); i++) {
            for (int j = 0; j < grid[0].size(); j++) {
                if (grid[i][j] == 2) {
                    q.push({i, j}); // 将腐烂的橘子加入队列
                } else if (grid[i][j] == 1) {
                    fresh++; // 统计新鲜橘子的数量
                }
            }
        }
        // 定义四个方向的移动
        vector<pair<int, int>> directions{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        int minutes = 0; // 经过的时间
        // 开始BFS
        while (!q.empty() && fresh > 0) {
            int size = q.size(); // 当前层的腐烂橘子数量
            for (int i = 0; i < size; i++) {
                auto [x, y] = q.front(); q.pop();
                for (auto& dir : directions) {
                    int nx = x + dir.first;
                    int ny = y + dir.second;
                    // 检查边界条件，并且如果相邻的是新鲜橘子，则将其腐烂
                    if (nx >= 0 && nx < grid.size() && ny >= 0 && ny < grid[0].size() && grid[nx][ny] == 1) {
                        grid[nx][ny] = 2;
                        fresh--; // 新鲜橘子数量减少
                        q.push({nx, ny}); // 将新的腐烂橘子加入队列
                    }
                }
            }
            minutes++; // 经过了一分钟
        }
        // 如果还有新鲜橘子，返回-1，否则返回经过的分钟数
        return fresh > 0 ? -1 : minutes;
    }
};
```
