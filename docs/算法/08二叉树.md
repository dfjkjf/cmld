---
sort: 8
---

# 二叉树

二叉树是链表的扩展，由于其一分二的特点，其在排序和搜索的场景下效率较高。

## 1. 二叉树的前/中/后序遍历

给定一个二叉树的根节点 `root` ，返回 _它的 **前/中/后序** 遍历_ 。

### 思路

1. 递归

前序遍历二叉树的过程可以递归地定义如下：
1. 访问根节点；
2. 遍历左子树；
3. 遍历右子树。

假设我们有以下二叉树：
```
    A
   / \
  B   C
 / \
D   E
```
前序遍历的结果为：A -> B -> D -> E -> C

中序遍历二叉树的过程可以递归地定义如下：
1. 遍历左子树；
2. 访问根节点；
3. 遍历右子树。

假设我们有以下二叉树：
```
    A
   / \
  B   C
 / \
D   E
```
中序遍历的结果为：D -> B -> E -> A -> C

后序遍历二叉树的过程可以递归地定义如下：
1. 遍历左子树；
2. 遍历右子树；
3. 访问根节点。

假设我们有以下二叉树：
```
    A
   / \
  B   C
 / \
D   E
```
中序遍历的结果为：D -> E -> B -> C -> A

```cpp
class Solution {
    void inorder(TreeNode* root, vector<int> &res)
    {
        if (!root) return;

        /* 前序遍历 */
        res.push_back(root->val);
        inorder(root->left, res);
        inorder(root->right, res);
        
        /* 中序遍历 */
        inorder(root->left, res);
        res.push_back(root->val);
        inorder(root->right, res);

        /* 后序遍历 */
        inorder(root->left, res);
        inorder(root->right, res);
        res.push_back(root->val);
    }
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        inorder(root, res);
        return res;
    }
};
```

2. 迭代

两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来

```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> stk;

        /* 前序遍历 */
        // 将当前节点的所有左子节点压入栈
        while (root != nullptr || !stk.empty())
        {
            while (root != nullptr) {
                // 访问根节点
                res.push_back(root->val);
                stk.push(root);
                root = root->left;
            }

            // 当没有左子节点时，从栈中弹出节点
            root = stk.top();
            stk.pop();

            // 准备访问右子节点
            root = root->right;
        }

        /* 中序遍历 */
        // 将当前节点的所有左子节点压入栈
        while (root != nullptr || !stk.empty())
        {
            while (root != nullptr) {
                stk.push(root);
                root = root->left;
            }

            // 当没有左子节点时，从栈中弹出节点并访问
            root = stk.top();
            stk.pop();
            res.push_back(root->val);

            // 准备访问右子节点
            root = root->right;
        }
        
        /* 后序遍历：和前序一样，结果反转 */
        // 将当前节点的所有左子节点压入栈
        while (root != nullptr || !stk.empty())
        {
            while (root != nullptr) {
                // 访问根节点
                res.push_back(root->val);
                stk.push(root);
                root = root->left;
            }

            // 当没有左子节点时，从栈中弹出节点
            root = stk.top();
            stk.pop();

            // 准备访问右子节点
            root = root->right;
        }
        // 使用std::reverse来反转vector
        std::reverse(res.begin(), res.end());

        return res;
    }
};
```

## 2. 二叉树的最大深度

给定一个二叉树 `root` ，返回其最大深度。

二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

**示例 1：**

![](./imags/二叉树的最大深度.jpg)

```
<b>输入：</b>root = [3,9,20,null,null,15,7]
<b>输出：</b>3
```

**示例 2：**

```
<b>输入：</b>root = [1,null,2]
<b>输出：</b>2
```

**提示：**

-   树中节点的数量在 `[0, 10^4]` 区间内。
-   `-100 <= Node.val <= 100`

### 思路

使用递归的方法来求解二叉树的最大深度。递归的基本思想是：对于任意一个节点，它的最大深度等于其左子树和右子树的最大深度中的较大值加1。


```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        // 如果节点为空，返回深度为0
        if (root == NULL) return 0;
        
        // 递归计算左子树的最大深度
        int leftDepth = maxDepth(root->left);
        // 递归计算右子树的最大深度
        int rightDepth = maxDepth(root->right);
        
        // 当前节点的最大深度为左子树和右子树的最大深度中的较大值加1
        return max(leftDepth, rightDepth) + 1;
    }
};
```

## 3. 翻转二叉树

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

**示例 1：**

![](./imags/翻转二叉树.jpg)

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**提示：**

-   树中节点数目范围在 `[0, 100]` 内
-   `-100 <= Node.val <= 100`

### 思路

翻转二叉树就是将二叉树中的每个节点的左右子节点交换位置。这个操作对于每个节点都要进行，无论它是叶子节点还是内部节点。

翻转二叉树的问题可以使用递归的方式来解决。递归的思路非常直接：
1. 交换当前节点的左右子节点。
2. 递归地对左子树进行翻转。
3. 递归地对右子树进行翻转。

递归的终止条件是当前节点为空，即当到达叶子节点的子节点时，我们不再进行任何操作。

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == nullptr) return nullptr; // 递归终止条件

        // 交换当前节点的左右子节点
        swap(root->left, root->right);

        // 递归翻转左子树
        invertTree(root->left);
        // 递归翻转右子树
        invertTree(root->right);

        return root;
    }
};
```

## 4. 对称二叉树

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

**示例 1：**

![](./imags/对称二叉树.png)

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

### 思路

对称二叉树是指一个二叉树，其左右子树是镜像对称的。具体来说，对于树中的任意节点，它的**左子节点的值必须等于它的右子节点的值**，并且它的左子树和右子树也是对称的。

使用递归的方法，具体步骤如下：
1. 如果树为空，则它是对称的。
2. 定义一个递归函数，比较两个节点，一个是树的左子节点，另一个是树的右子节点。
3. 在递归函数中，首先检查两个节点是否都为空，如果是，则它们是对称的。
4. 接着检查两个节点中有一个为空而另一个不为空，或者两个节点的值不相等，这两种情况都说明树不对称。
5. 如果以上情况都不满足，那么递归地比较左节点的左子树和右节点的右子树，以及左节点的右子树和右节点的左子树。

```cpp
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true; // 空树是对称的
        return isMirror(root->left, root->right); // 比较左右子树
    }

    bool isMirror(TreeNode* left, TreeNode* right) {
        if (left == NULL && right == NULL) return true; // 两个节点都为空
        if (left == NULL || right == NULL) return false; // 一个节点为空，另一个不为空
        // 比较两个节点的值，并递归比较它们的子树
        return (left->val == right->val) 
            && isMirror(left->left, right->right) 
            && isMirror(left->right, right->left);
    }
};
```

## 5. 二叉树的直径

给你一棵二叉树的根节点，返回该树的 **直径** 。

二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。

两节点之间路径的 **长度** 由它们之间边数表示。

**示例 1：**

![](./imags/二叉树的直径.jpg)

```
输入：root = [1,2,3,4,5]
输出：3
解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。
```

**示例 2：**

```
输入：root = [1,2]
输出：1
```

### 思路

计算二叉树的直径，可以通过计算每个节点的左子树和右子树的深度来完成。
```text
直径 = 左子树深度 + 右子树深度
```
方法：
1. 遍历每个节点。
2. 对于每个节点，计算其左子树和右子树的深度。
3. 更新最大直径长度。


```cpp
class Solution {
public:
    int diameterOfBinaryTree(TreeNode* root, int& diameter) {
        if (root == NULL) return 0; // 空节点的深度为0

        int leftDepth = diameterOfBinaryTree(root->left, diameter); // 左子树的深度
        int rightDepth = diameterOfBinaryTree(root->right, diameter); // 右子树的深度

        // 更新直径长度
        diameter = max(diameter, leftDepth + rightDepth);

        // 返回当前节点的深度
        return 1 + max(leftDepth, rightDepth);
    }

    int diameterOfBinaryTree(TreeNode* root) {
        int diameter = 0;
        diameterOfBinaryTree(root, diameter);
        return diameter;
    }
};
```

## 6. 二叉树的层序遍历

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

### 思路

层序遍历通常使用一个队列（Queue）来实现。以下是实现步骤：
1. 初始化一个队列，将根节点入队。
2. 当队列不为空时，进行以下操作：
    - 队列的长度表示当前层的节点数。
    - 依次从队列中出队节点，并将它们的值加入结果列表。
    - 如果出队节点有左子节点，则将左子节点入队。
    - 如果出队节点有右子节点，则将右子节点入队。
3. 重复步骤2，直到队列为空。

```cpp
class Solution {
public:
    std::vector<std::vector<int>> levelOrder(TreeNode* root) {
        std::vector<std::vector<int>> result;
        if (root == nullptr) return result; // 如果根节点为空，直接返回空列表

        std::queue<TreeNode*> q;
        q.push(root); // 将根节点入队

        while (!q.empty()) {
            int levelSize = q.size(); // 当前层的节点数量
            std::vector<int> level; // 存储当前层的节点值

            for (int i = 0; i < levelSize; ++i) {
                TreeNode* node = q.front(); // 获取队列头部节点
                q.pop(); // 出队
                level.push_back(node->val); // 将节点值加入当前层列表

                // 将左子节点入队
                if (node->left != nullptr) q.push(node->left);
                // 将右子节点入队
                if (node->right != nullptr) q.push(node->right);
            }

            result.push_back(level); // 将当前层的结果加入最终结果
        }

        return result;
    }
};
```

## 7. 验证二叉搜索树

给你一个二叉树的根节点`root`，判断其是否是一个有效的二叉搜索树。

二叉搜索树（Binary Search Tree，BST）特点：
1. **每个节点的值大于其左子树中所有节点的值，小于其右子树中所有节点的值。**
2. **左右子树也都是二叉搜索树。**
3. **没有重复的节点。**

### 思路

- 我们可以使用递归的方法。在递归过程中，我们需要维护一个当前节点值的合法范围，即每个节点必须大于其左子树中的所有节点值，并且小于其右子树中的所有节点值。
- isValidBSTHelper 是一个递归函数，它接受三个参数：当前节点、当前节点值的下界和上界。
- 在递归过程中，我们检查当前节点的值是否在合法范围内，如果不在这个范围内，则返回false。
- 我们递归地检查左子树和右子树，对于左子树，上界变为当前节点的值；对于右子树，下界变为当前节点的值。
- isValidBST 函数是isValidBSTHelper的包装函数，它使用LLONG_MIN和LLONG_MAX作为初始上下界，开始递归检查。

```cpp
class Solution {
public:
    bool isValidBSTHelper(TreeNode* node, long long lower, long long upper) {
        if (node == nullptr) return true; // 空树是二叉搜索树
        if (node->val <= lower || node->val >= upper) return false; // 当前节点值不在合法范围内

        // 递归检查左子树和右子树
        return isValidBSTHelper(node->left, lower, node->val) && isValidBSTHelper(node->right, node->val, upper);
    }

    bool isValidBST(TreeNode* root) {
        return isValidBSTHelper(root, LLONG_MIN, LLONG_MAX);
    }
};
```

## 8. 将有序数组转化为二叉搜索树

给定一个升序排列的整数数组`nums`，将其转换为一棵高度平衡的二叉搜索树。

**高度平衡**的二叉树是指任意节点的左右子树的深度差都不超过 1。

### 思路

由于数组是有序的，我们可以采用以下策略来构建高度平衡的二叉搜索树：
1. 选择数组中间的元素作为根节点，这样可以保证左右子树的节点数目尽可能相等，从而保证树的高度平衡。
2. 递归地对左半部分数组进行相同的操作，构建左子树。
3. 递归地对右半部分数组进行相同的操作，构建右子树。

```cpp
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        if (nums.empty()) return nullptr; // 如果数组为空，返回空指针

        return helper(nums, 0, nums.size() - 1); // 调用辅助函数构建二叉搜索树
    }

    TreeNode* helper(vector<int>& nums, int left, int right) {
        if (left > right) return nullptr; // 递归终止条件

        int mid = left + (right - left) / 2; // 计算中间位置，防止溢出
        TreeNode* root = new TreeNode(nums[mid]); // 创建根节点

        root->left = helper(nums, left, mid - 1); // 递归构建左子树
        root->right = helper(nums, mid + 1, right); // 递归构建右子树

        return root; // 返回构建好的子树
    }
};
```

## 9. 二叉搜索树中第k小的元素

给定一个二叉搜索树，编写一个函数来查找树中的第k个最小元素。

### 思路

在二叉搜索树中，中序遍历的结果是一个有序的数组。因此，如果我们对二叉搜索树进行中序遍历，那么遍历到的第k个元素就是第k小的元素。

1. inorderTraversal 是一个递归函数，它执行中序遍历，并且有一个计数器k来跟踪当前遍历到的节点是第几小的元素。
2. 当k减到0时，表示我们已经找到了第k小的元素，将其值赋给result，并设置found标志为true来停止遍历。
3. kthSmallest 函数初始化result和found，并调用inorderTraversal函数。

```cpp
class Solution {
public:
    void inorderTraversal(TreeNode* node, int& k, int& result, bool& found) {
        if (node == nullptr || found) return;

        // 遍历左子树
        inorderTraversal(node->left, k, result, found);

        // 处理当前节点
        k--;
        if (k == 0) {
            result = node->val;
            found = true;
            return;
        }

        // 遍历右子树
        inorderTraversal(node->right, k, result, found);
    }

    int kthSmallest(TreeNode* root, int k) {
        int result;
        bool found = false;
        inorderTraversal(root, k, result, found);
        return result;
    }
};
```

## 二叉树展开为链表

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：
-   展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
-   展开后的单链表应该与二叉树 **先序遍历** 顺序相同。

**示例 1：**

![](./imags/二叉树展开为链表.jpg)

```
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [0]
输出：[0]
```

**提示：**

-   树中结点数在范围 `[0, 2000]` 内
-   `-100 <= Node.val <= 100`

**进阶：**你可以使用原地算法（`O(1)` 额外空间）展开这棵树吗？

### 思路

要将二叉树展开为链表，我们可以遵循以下步骤：
1. 先序遍历：首先，我们需要按照先序遍历的顺序访问每个节点。这是因为题目要求展开后的链表与先序遍历顺序相同。
2. 修改指针：在遍历的过程中，我们需要将每个节点的左子指针设为NULL，并将右子指针指向下一个遍历到的节点。

具体步骤如下：
1. 使用一个栈或者递归来进行先序遍历。
2. 在遍历过程中，记录前一个访问的节点，并将当前节点的左子指针设为NULL，右子指针指向前一个节点。


```cpp
class Solution {
    // 用于记录前一个访问的节点
    TreeNode* prev = NULL;
public:
    void flatten(TreeNode* root) {
        if (!root) return;
    
        // 先递归处理右子树
        flatten(root->right);
        // 再递归处理左子树
        flatten(root->left);
        
        // 将当前节点的右子指针指向前一个节点
        root->right = prev;
        // 将当前节点的左子指针设为NULL
        root->left = NULL;
        // 更新前一个节点为当前节点
        prev = root;
    }
};
```

## 从前序与中序遍历构造二叉树

给定一棵树的前序遍历和中序遍历的结果，请构造该二叉树并返回其根节点。

**示例 1：**
```
输入:
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
输出:
    3
   / \
  9  20
    /  \
   15   7
```

### 思路

要从前序与中序遍历结果中构造二叉树，我们可以遵循以下步骤：
1. **确定根节点**：前序遍历的第一个元素即为根节点。
2. **分割中序遍历**：根据根节点在中序遍历中的位置，可以将中序遍历分为左子树和右子树两部分。
3. **递归构造**：递归地在左子树和右子树中重复上述步骤。

具体步骤如下：
- 在前序遍历中找到根节点。
- 在中序遍历中找到根节点的位置，这将左子树和右子树分开。
- 递归地构造左子树和右子树。

```cpp
class Solution {
private:
    unordered_map<int, int> indexMap; // 用于存储中序遍历中每个值对应的位置
public:
    TreeNode* myBuildTree(const vector<int>& preorder, const vector<int>& inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) {
        if (preorder_left > preorder_right) {
            return NULL;
        }
        
        // 前序遍历中的第一个元素即为根节点
        int preorder_root = preorder_left;
        // 在中序遍历中定位根节点
        int inorder_root = indexMap[preorder[preorder_root]];
        
        // 先构造根节点
        TreeNode* root = new TreeNode(preorder[preorder_root]);
        // 左子树的节点数目
        int size_left_subtree = inorder_root - inorder_left;
        
        // 递归构造左子树并连接到根节点
        // 先序遍历中左子树的区间为 [preorder_left + 1, preorder_left + size_left_subtree]
        // 中序遍历中左子树的区间为 [inorder_left, inorder_root - 1]
        root->left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);
        
        // 递归构造右子树并连接到根节点
        // 先序遍历中右子树的区间为 [preorder_left + size_left_subtree + 1, preorder_right]
        // 中序遍历中右子树的区间为 [inorder_root + 1, inorder_right]
        root->right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);
        
        return root;
    }
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int n = preorder.size();
        // 构建中序遍历的哈希映射，帮助我们快速定位根节点
        for (int i = 0; i < n; ++i) {
            indexMap[inorder[i]] = i;
        }
        // 调用递归函数构建二叉树
        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);
    }
};
```

## 路径总和III

## 二叉树的最近公共祖先

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

**最近公共祖先**的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

**示例 1：**

![](./imags/二叉树的最近公共祖先.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

**示例 2：**

![](./imags/二叉树的最近公共祖先.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
```

**示例 3：**

```
输入：root = [1,2], p = 1, q = 2
输出：1
```

**提示：**

-   树中节点数目在范围 `[2, 10^5]` 内。
-   `-10^9 <= Node.val <= 10^9`
-   所有 `Node.val` `互不相同` 。
-   `p != q`
-   `p` 和 `q` 均存在于给定的二叉树中。

### 思路

要找到两个节点的最近公共祖先，我们可以使用以下步骤：
1. 后序遍历：我们从根节点开始，递归地对左右子树进行遍历。
2. 递归终止条件：如果当前节点为空，或者当前节点是 p 或 q 中的一个，则返回当前节点。
3. 递归逻辑：
    - 从左子树中找到 p 或 q 的最近公共祖先。
    - 从右子树中找到 p 或 q 的最近公共祖先。
    - 如果左右子树都找到了 p 或 q，说明当前节点就是最近公共祖先。
    - 如果只有左子树找到了，那么最近公共祖先在左子树中。
    - 如果只有右子树找到了，那么最近公共祖先在右子树中。

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        // 如果当前节点为空，或者当前节点是 p 或 q，则返回当前节点
        if (root == NULL || root == p || root == q) return root;
        
        // 递归查找左右子树
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        
        // 如果左右子树都找到了 p 或 q，说明当前节点就是最近公共祖先
        if (left != NULL && right != NULL) return root;
        
        // 否则，返回非空的那个子树
        return left != NULL ? left : right;
    }
};
```