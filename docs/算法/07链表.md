---
sort: 7
---

# 链表

- 链表插入和删除数据效率高

## 1. 相交链表

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

### 思路

- 一眼哈希表，先全部存入一个链表，再遍历另一个链表的节点是否在哈希表中。

1. 哈希表

```cpp
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if (headA == nullptr || headB == nullptr)
            return nullptr;
        
        ListNode *p1 = headA, *p2 = headB;
        unordered_set<ListNode *> visited;
        while (p1)
        {
            visited.insert(p1);
            p1 = p1->next;
        }

        while (p2)
        {
            if (visited.find(p2) != visited.end())
                return p2;
            p2 = p2->next;
        }
        return nullptr;
    }
};
```

2. 双指针
- 如果两个链表相交，则
    1. 最后一个节点相同
    2. 两链表长度差 = 两链表未相交前的长度差
- 两指针遍历各自链表，快指针先移动长度差，两指针才开始同时移动，都到底前指向同一节点则相交，此节点是相交点，否则不相交

```cpp
class Solution {
    int getLength(ListNode* head) {
        int ans = 0;
        for (;head;head = head->next) ++ans;
        return ans;
    }
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* currA = headA;
        ListNode* currB = headB;

        int lenA = 0;
        while (currA->next != nullptr)
        {
            currA = currA->next;
            lenA++;
        }
        int lenB = 0;
        while (currB->next != nullptr)
        {
            currB = currB->next;
            lenB++;
        }
        if (currA != currB) return nullptr;

        int step = abs(lenA - lenB);
        if (lenA > lenB) {
            while (step > 0) {
                headA = headA->next;
                step--;
            }
        } else {
            while (step > 0) {
                headB = headB->next;
                step--;
            }
        }
        while (headA != headB) {
            headA = headA->next;
            headB = headB->next;
        }
        return headA;
    }
};
```

## 2. 反转链表

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

**示例 1：**

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

**示例 2：**

```
输入：head = [1,2]
输出：[2,1]
```

**示例 3：**

```
输入：head = []
输出：[]
```

**提示：**

-   链表中节点的数目范围是 `[0, 5000]`
-   `-5000 <= Node.val <= 5000`

**进阶：** 链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？

### 思路

1. 保存当前节点、上个节点、下个节点
2. 将当前节点的next指向上个节点，此时前两个节点反转
3. 重复1 2，直到当前节点为空


```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* prev = nullptr;
        ListNode* curr = head;
        while (curr) {
            ListNode* next = curr->next;
            curr->next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
};
```

## 3. 回文链表

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

**示例 1：**

```
输入：head = [1,2,2,1]
输出：true
```

**示例 2：**

```
输入：head = [1,2]
输出：false
```

**提示：**

-   链表中节点数目在范围`[1, 10^5]` 内
-   `0 <= Node.val <= 9`

**进阶：** 你能否用 `O(n)` 时间复杂度和 `O(1)` 空间复杂度解决此题？

### 思路

- 将值复制到数组中后用双指针法

```cpp
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        vector<int> vals;
        while (head != nullptr) {
            vals.emplace_back(head->val);
            head = head->next;
        }
        for (int i = 0, j = (int)vals.size() - 1; i < j; ++i, --j) {
            if (vals[i] != vals[j]) {
                return false;
            }
        }
        return true;
    }
};
```

- 二分后反转
- 两个链表遍历一一对比，出现不等即返回

```cpp
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if (head == nullptr) {
            return true;
        }

        // 找到前半部分链表的尾节点并反转后半部分链表
        ListNode* firstHalfEnd = endOfFirstHalf(head);
        ListNode* secondHalfStart = reverseList(firstHalfEnd->next);

        // 判断是否回文
        ListNode* p1 = head;
        ListNode* p2 = secondHalfStart;
        bool result = true;
        while (result && p2 != nullptr) {
            if (p1->val != p2->val) {
                result = false;
            }
            p1 = p1->next;
            p2 = p2->next;
        }        

        // 还原链表并返回结果
        firstHalfEnd->next = reverseList(secondHalfStart);
        return result;
    }

    ListNode* reverseList(ListNode* head) {
        ListNode* prev = nullptr;
        ListNode* curr = head;
        while (curr != nullptr) {
            ListNode* nextTemp = curr->next;
            curr->next = prev;
            prev = curr;
            curr = nextTemp;
        }
        return prev;
    }

    ListNode* endOfFirstHalf(ListNode* head) {
        ListNode* fast = head;
        ListNode* slow = head;
        while (fast != nullptr && fast->next != nullptr) {
            fast = fast->next->next;
            slow = slow->next;
        }
        return slow;
    }
};
```

## 4. 环形链表

给你一个链表的头节点 `head` ，判断链表中是否有环。

### 思路

链表有环指针遍历入环后则在环内无限循环，可以使用追击问题方法来解决这个问题。

1. 定义两个指针，一个快指针（fast pointer）每次移动两步，一个慢指针（slow pointer）每次移动一步。
2. 如果链表中存在环，那么快指针一定会在某个时刻追上慢指针。
3. 如果快指针到达链表末尾（即指向 nullptr），则说明链表中没有环。

```cpp
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast!= nullptr && fast->next!= nullptr) {
            slow = slow->next;
            fast = fast->next->next;
            if (slow == fast) {
                return true;
            }
        }
        return false;
    }
};
```


## 5. 环形链表2

给定一个链表的头节点 `head` ，返回链表开始入环的第一个节点。 _如果链表无环，则返回 `null`。_

### 思路

1. 哈希表

```cpp
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        unordered_set<ListNode *> visited;
        while (head != nullptr) {
            if (visited.contains(head)) {
                return head;
            }
            visited.insert(head);
            head = head->next;
        }
        return nullptr;
    }
};
```

2. 双指针
    1. 首先使用快慢指针判断链表是否有环，如果没有环则直接返回 `nullptr`。
    2. 如果有环，计算环的长度。通过一个临时指针在相遇点继续移动，直到再次回到相遇点，统计移动的次数得到环的长度。
    3. 然后，让一个指针先移动环的长度步，另一个指针从头节点开始，两个指针同时移动，当它们相遇时，相遇的节点就是环的入口节点。

**三、C++代码实现**

```cpp
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* slow = head;
        ListNode* fast = head;
        bool hasCycle = false;
        while (fast!= nullptr && fast->next!= nullptr) {
            slow = slow->next;
            fast = fast->next->next;
            if (slow == fast) {
                hasCycle = true;
                break;
            }
        }
        if (!hasCycle) return nullptr;

        // 计算环的长度
        int cycleLength = 1;
        ListNode* temp = slow->next;
        while (temp!= slow) {
            temp = temp->next;
            cycleLength++;
        }

        // 找到环的入口
        ListNode* first = head;
        ListNode* second = head;
        for (int i = 0; i < cycleLength; i++) {
            first = first->next;
        }
        while (first!= second) {
            first = first->next;
            second = second->next;
        }
        return first;
    }
};
```

## 6. 合并两个有序链表

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**示例 1：**

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**示例 2：**

```
输入：l1 = [], l2 = []
输出：[]
```

**示例 3：**

```
输入：l1 = [], l2 = [0]
输出：[0]
```

**提示：**

-   两个链表的节点数目范围是 `[0, 50]`
-   `-100 <= Node.val <= 100`
-   `l1` 和 `l2` 均按 **非递减顺序** 排列

### 思路

- 维护一个新的链表头指针和一个尾指针，用于构建合并后的链表。
- 比较两个输入链表的当前节点值，将较小值的节点添加到新链表中，并移动相应链表的指针。
- 重复这个过程，直到两个输入链表中的一个为空。
- 然后将另一个非空链表的剩余部分添加到新链表的末尾。

```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode dummy(0); // 创建一个哑节点
        ListNode* tail = &dummy;

        while (l1 && l2) {
            if (l1->val < l2->val) {
                tail->next = l1;
                l1 = l1->next;
            } else {
                tail->next = l2;
                l2 = l2->next;
            }
            tail = tail->next;
        }

        tail->next = l1? l1 : l2;

        return dummy.next;
    }
};
```

## 7. 两数相加

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例 1：**

![](./imags/两数相加.jpg)

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

**示例 2：**

```
输入：l1 = [0], l2 = [0]
输出：[0]
```

**示例 3：**

```
输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
```

**提示：**

-   每个链表中的节点数在范围 `[1, 100]` 内
-   `0 <= Node.val <= 9`
-   题目数据保证列表表示的数字不含前导零

### 思路

此题较为简单，同时遍历两个链表值相加即可。注意进位

```cpp
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode *root = new ListNode, *curr = root;
        int carry = 0;
        while (l1 || l2 || carry) {
            int n1 = l1 ? l1->val: 0;
            int n2 = l2 ? l2->val: 0;
            int sum = n1 + n2 + carry;
            if (sum > 9) {
                sum -= 10;
                carry = 1;
            } else {
                carry = 0;
            }
            curr->next = new ListNode(sum);
            curr = curr->next;
            if (l1) {
                l1 = l1->next;
            }
            if (l2) {
                l2 = l2->next;
            }
        }
        return root->next;
    }
};
```

## 删除链表的倒数第n个节点

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**示例 1：**

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

**示例 2：**

```
输入：head = [1], n = 1
输出：[]
```

**示例 3：**

```
输入：head = [1,2], n = 1
输出：[1]
```

**提示：**

-   链表中结点的数目为 `sz`
-   `1 <= sz <= 30`
-   `0 <= Node.val <= 100`
-   `1 <= n <= sz`

**进阶：**你能尝试使用一趟扫描实现吗？

### 思路

同步移动，**注意** 如果删除的是头节点。使用哑节点：哑节点可以简化边界条件的处理，特别是当要删除的节点是头节点时

```cpp
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        // 创建一个哑节点，指向头节点，方便处理删除头节点的情况
        ListNode* dummy = new ListNode(0);
        dummy->next = head;

        ListNode* first = head;
        ListNode* second = dummy;
        // 快指针先走n步
        for (int i = 0; i < n; ++i) {
            first = first->next;
        }
        // 快慢指针同时走，直到快指针走到链表末尾
        while (first) {
            first = first->next;
            second = second->next;
        }
        second->next = second->next->next;
        ListNode* ans = dummy->next;
        delete dummy;
        return ans;
    }
};
```

## 两两交换链表中的节点

### 思路

- 遍历每次前进两步，与前一个节点反转，重复
- 为了完成第一次走两步，可以在头节点前创建一个虚拟节点

## K个一组反转链表

### 思路

1. 每次取出K个元素
2. 翻转后拼接到结果上

```cpp
class Solution {
public:
    // 辅助函数，用于翻转链表的一部分
    ListNode* reverse(ListNode* head, ListNode* tail) {
        ListNode* prev = tail->next;
        ListNode* p = head;
        while (prev != tail) {
            ListNode* next = p->next;
            p->next = prev;
            prev = p;
            p = next;
        }
        return prev;
    }

    ListNode* reverseKGroup(ListNode* head, int k) {
        // 创建一个哑节点，指向头节点
        ListNode* dummy = new ListNode(0);
        dummy->next = head;
        
        // 初始化指针
        ListNode* pre = dummy;
        ListNode* end = dummy;
        
        // 遍历链表，每次循环翻转K个节点
        while (end->next != NULL) {
            // 移动end指针，找到K个节点的尾部
            for (int i = 0; i < k && end != NULL; ++i) {
                end = end->next;
            }
            // 如果不足K个节点，不需要翻转，直接返回
            if (end == NULL) break;
            
            // 记录下一个小组的头部
            ListNode* next = end->next;
            
            // 翻转当前小组
            ListNode* start = pre->next;
            pre->next = reverse(start, end);
            
            // 连接翻转后的小组与下一个小组
            start->next = next;
            pre = start;
            end = pre;
        }
        
        // 返回新的头节点
        ListNode* newHead = dummy->next;
        delete dummy; // 释放哑节点的内存
        return newHead;
    }
};
```

## 随机链表的复制

## 排序链表

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。

### 思路

归并排序是一种分治算法，它将链表分成两半，分别对这两半进行排序，然后将排序好的两半合并成一个有序的链表。

以下是归并排序链表的步骤：
1. 分割链表
    - 找到链表的中点，可以使用快慢指针的方法。
    - 将链表从中点分割成两个子链表。
2. 递归排序：对两个子链表分别进行递归排序。
3. 合并链表：将两个已排序的子链表合并成一个有序的链表。

```cpp
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};
// 合并两个有序链表
ListNode* merge(ListNode* l1, ListNode* l2) {
    if (!l1) return l2;
    if (!l2) return l1;
    
    if (l1->val < l2->val) {
        l1->next = merge(l1->next, l2);
        return l1;
    } else {
        l2->next = merge(l1, l2->next);
        return l2;
    }
}
// 使用快慢指针找到链表的中点
ListNode* findMiddle(ListNode* head) {
    if (!head || !head->next) return head;

    ListNode* slow = head;
    ListNode* fast = head;
    
    while (fast->next && fast->next->next) {
        slow = slow->next;
        fast = fast->next->next;
    }
    
    return slow;
}
// 归并排序链表
ListNode* sortList(ListNode* head) {
    if (!head || !head->next) return head;
    
    // 分割链表
    ListNode* middle = findMiddle(head);
    ListNode* nextOfMiddle = middle->next;
    middle->next = NULL;
    
    // 递归排序两半
    ListNode* left = sortList(head);
    ListNode* right = sortList(nextOfMiddle);
    
    // 合并两半
    return merge(left, right);
}
```

## 合并K个升序链表

## LRU缓存

请你设计并实现一个满足  [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类：

-   `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
-   `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
-   `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

**示例：**

```
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

**提示：**

-   `1 <= capacity <= 3000`
-   `0 <= key <= 10000`
-   `0 <= value <= 10^5`
-   最多调用 `2 * 10^5` 次 `get` 和 `put`

### 思路

要实现一个LRU缓存，我们需要以下两个数据结构：
1. 哈希表（HashMap）：用于存储键值对，并且能够以O(1)的时间复杂度查找到键对应的值。
2. 双向链表（LinkedList）：用于按照访问顺序存储键值对，使得最近访问的元素总是位于链表的前端，最少访问的元素位于链表的尾部。

以下是LRU缓存的基本操作：
1. 获取数据（get操作）
    - 如果键存在于缓存中，将对应的节点移动到链表的头部，并返回节点的值。
    - 如果键不存在于缓存中，返回-1。
2. 插入数据（put操作）
    - 如果键已存在，更新节点的值，并将该节点移动到链表头部。
    - 如果键不存在：
        - 如果缓存已满，删除链表尾部的节点，并在哈希表中删除对应的键。
        - 将新节点添加到链表头部，并在哈希表中添加对应的键。

```cpp
class LRUCache {
private:
    // 定义双向链表的节点结构
    struct ListNode {
        int key;
        int value;
        ListNode* prev;
        ListNode* next;
        ListNode(int k, int v) : key(k), value(v), prev(nullptr), next(nullptr) {}
    };

    unordered_map<int, ListNode*> cache; // 哈希表，存储键和对应节点的指针
    ListNode* head; // 虚拟头节点
    ListNode* tail; // 虚拟尾节点
    int capacity; // 缓存容量
    int size; // 当前缓存中的元素数量

    // 将节点移动到头部
    void moveToHead(ListNode* node) {
        removeNode(node);
        addToHead(node);
    }

    // 将节点添加到头部
    void addToHead(ListNode* node) {
        node->next = head->next;
        node->prev = head;
        head->next->prev = node;
        head->next = node;
    }

    // 删除节点
    void removeNode(ListNode* node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }

    // 删除尾部节点
    ListNode* popTail() {
        ListNode* res = tail->prev;
        removeNode(res);
        return res;
    }
public:
    LRUCache(int capacity) : capacity(capacity), size(0) {
        // 使用虚拟头尾节点
        head = new ListNode(0, 0);
        tail = new ListNode(0, 0);
        head->next = tail;
        tail->prev = head;
    }
    
    ~LRUCache() {
        // 析构函数，释放内存
        for (auto& it : cache) {
            delete it.second;
        }
        delete head;
        delete tail;
    }

    int get(int key) {
        if (!cache.count(key)) {
            return -1;
        }
        ListNode* node = cache[key];
        moveToHead(node);
        return node->value;
    }
    
    void put(int key, int value) {
        if (cache.count(key)) {
            ListNode* node = cache[key];
            node->value = value;
            moveToHead(node);
        } else {
            ListNode* newNode = new ListNode(key, value);
            cache[key] = newNode;
            addToHead(newNode);
            size++;
            if (size > capacity) {
                ListNode* tail = popTail();
                cache.erase(tail->key);
                delete tail;
                size--;
            }
        }
    }
};
```
