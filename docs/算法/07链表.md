---
sort: 7
---

# 链表

- 链表插入和删除数据效率高

## 1. 相交链表

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

### 思路

- 一眼哈希表，先全部存入一个链表，再遍历另一个链表的节点是否在哈希表中。

1. 哈希表

```cpp
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if (headA == nullptr || headB == nullptr)
            return nullptr;
        
        ListNode *p1 = headA, *p2 = headB;
        unordered_set<ListNode *> visited;
        while (p1)
        {
            visited.insert(p1);
            p1 = p1->next;
        }

        while (p2)
        {
            if (visited.find(p2) != visited.end())
                return p2;
            p2 = p2->next;
        }
        return nullptr;
    }
};
```

2. 双指针
- 如果两个链表相交，则
    1. 最后一个节点相同
    2. 两链表长度差 = 两链表未相交前的长度差
- 两指针遍历各自链表，快指针先移动长度差，两指针才开始同时移动，都到底前指向同一节点则相交，此节点是相交点，否则不相交

```cpp
class Solution {
    int getLength(ListNode* head) {
        int ans = 0;
        for (;head;head = head->next) ++ans;
        return ans;
    }
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* currA = headA;
        ListNode* currB = headB;

        int lenA = 0;
        while (currA->next != nullptr)
        {
            currA = currA->next;
            lenA++;
        }
        int lenB = 0;
        while (currB->next != nullptr)
        {
            currB = currB->next;
            lenB++;
        }
        if (currA != currB) return nullptr;

        int step = abs(lenA - lenB);
        if (lenA > lenB) {
            while (step > 0) {
                headA = headA->next;
                step--;
            }
        } else {
            while (step > 0) {
                headB = headB->next;
                step--;
            }
        }
        while (headA != headB) {
            headA = headA->next;
            headB = headB->next;
        }
        return headA;
    }
};
```

## 2. 反转链表

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

**示例 1：**

```
<strong>输入：</strong>head = [1,2,3,4,5]
<strong>输出：</strong>[5,4,3,2,1]
```

**示例 2：**

```
<strong>输入：</strong>head = [1,2]
<strong>输出：</strong>[2,1]
```

**示例 3：**

```
<strong>输入：</strong>head = []
<strong>输出：</strong>[]
```

**提示：**

-   链表中节点的数目范围是 `[0, 5000]`
-   `-5000 <= Node.val <= 5000`

**进阶：** 链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？

### 思路

1. 保存当前节点、上个节点、下个节点
2. 将当前节点的next指向上个节点，此时前两个节点反转
3. 重复1 2，直到当前节点未空


```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* prev = nullptr;
        ListNode* curr = head;
        while (curr) {
            ListNode* next = curr->next;
            curr->next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
};
```

## 3. 回文链表

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

**示例 1：**

```
<strong>输入：</strong>head = [1,2,2,1]
<strong>输出：</strong>true
```

**示例 2：**

```
<strong>输入：</strong>head = [1,2]
<strong>输出：</strong>false
```

**提示：**

-   链表中节点数目在范围`[1, 10<sup>5</sup>]` 内
-   `0 <= Node.val <= 9`

**进阶：** 你能否用 `O(n)` 时间复杂度和 `O(1)` 空间复杂度解决此题？

### 思路

- 将值复制到数组中后用双指针法

```cpp
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        vector<int> vals;
        while (head != nullptr) {
            vals.emplace_back(head->val);
            head = head->next;
        }
        for (int i = 0, j = (int)vals.size() - 1; i < j; ++i, --j) {
            if (vals[i] != vals[j]) {
                return false;
            }
        }
        return true;
    }
};
```

- 二分后反转
- 两个链表遍历一一对比，出现不等即返回

```cpp
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if (head == nullptr) {
            return true;
        }

        // 找到前半部分链表的尾节点并反转后半部分链表
        ListNode* firstHalfEnd = endOfFirstHalf(head);
        ListNode* secondHalfStart = reverseList(firstHalfEnd->next);

        // 判断是否回文
        ListNode* p1 = head;
        ListNode* p2 = secondHalfStart;
        bool result = true;
        while (result && p2 != nullptr) {
            if (p1->val != p2->val) {
                result = false;
            }
            p1 = p1->next;
            p2 = p2->next;
        }        

        // 还原链表并返回结果
        firstHalfEnd->next = reverseList(secondHalfStart);
        return result;
    }

    ListNode* reverseList(ListNode* head) {
        ListNode* prev = nullptr;
        ListNode* curr = head;
        while (curr != nullptr) {
            ListNode* nextTemp = curr->next;
            curr->next = prev;
            prev = curr;
            curr = nextTemp;
        }
        return prev;
    }

    ListNode* endOfFirstHalf(ListNode* head) {
        ListNode* fast = head;
        ListNode* slow = head;
        while (fast->next != nullptr && fast->next->next != nullptr) {
            fast = fast->next->next;
            slow = slow->next;
        }
        return slow;
    }
};
```

## 4. 环形链表

给你一个链表的头节点 `head` ，判断链表中是否有环。

### 思路

- 快慢指针从头遍历链表，块指针走两步慢指针走一步，快指针迟早能超过慢指针一圈

```cpp
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if (!head || !head->next) return false;
        ListNode *p1 = head, *p2 = head->next;
        while (p1 && p2 && p2->next)
        {
            if (p1 == p2) return true;
            p1 = p1->next;
            p2 = p2->next->next;
        }
        return false;
    }
};
```

## 5. 环形链表2

给定一个链表的头节点 `head` ，返回链表开始入环的第一个节点。 _如果链表无环，则返回 `null`。_

### 思路

1. 哈希表

```cpp
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        unordered_set<ListNode *> visited;
        while (head != nullptr) {
            if (visited.contains(head)) {
                return head;
            }
            visited.insert(head);
            head = head->next;
        }
        return nullptr;
    }
};
```

2. 有个数学结论：快慢指针相遇后，慢指针从头和快指针一起走，再次相遇的就是交点。

```cpp
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *slow = head, *fast = head;
        while (fast != nullptr)
        {
            slow = slow->next;
            if (fast->next == nullptr) {
                return nullptr;
            }
            fast = fast->next->next;
            if (fast == slow) {
                ListNode *ptr = head;
                while (ptr != slow) {
                    ptr = ptr->next;
                    slow = slow->next;
                }
                return ptr;
            }
        }
        return nullptr;
    }
};
```

## 6. 合并两个有序链表

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**示例 1：**

```
<strong>输入：</strong>l1 = [1,2,4], l2 = [1,3,4]
<strong>输出：</strong>[1,1,2,3,4,4]
```

**示例 2：**

```
<strong>输入：</strong>l1 = [], l2 = []
<strong>输出：</strong>[]
```

**示例 3：**

```
<strong>输入：</strong>l1 = [], l2 = [0]
<strong>输出：</strong>[0]
```

**提示：**

-   两个链表的节点数目范围是 `[0, 50]`
-   `-100 <= Node.val <= 100`
-   `l1` 和 `l2` 均按 **非递减顺序** 排列

### 思路

此题较为简单，重点是3个优化项：
1. 两链表判空，返回另一链表
2. 选择两链表头节点小的作合并节点的头
3. 合并完成后，剩余的链表衔接到合并链表后面


## 2. 两数相加

### 思路

此题较为简单，同时遍历两个链表值相加即可。注意进位


## 删除链表的倒数第n个节点

### 思路

同步移动

## 两两交换链表中的节点

### 思路

- 遍历每次前进两步，与前一个节点反转，重复
- 为了完成第一次走两步，可以在头节点前创建一个虚拟节点

## K个一组反转链表

## 随机链表的复制

## 排序链表

## 合并K个升序链表

## LRU缓存

