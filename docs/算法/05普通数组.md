---
sort: 5
---

# 普通数组

- 数组的特点是连续，长度确定，滑动窗口多适合

## 1. 最大子数组和

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组**

是数组中的一个连续部分。

**示例 1：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组[4,-1,2,1] 的和最大，为6 。
```

**示例 2：**

```
输入：nums = [1]
输出：1
```

**示例 3：**

```
输入：nums = [5,4,-1,7,8]
输出：23
```

**提示：**

-   `1 <= nums.length <= 10^5`
-   `-10^4 <= nums[i] <= 10^4`

**进阶：** 如果你已经实现复杂度为 `O(n)` 的解法，尝试使用更为精妙的 **分治法** 求解。


### 思路
- 连续和遍历 想到 滑动窗口
- 快慢指针遍历，快慢指针都到底才结束


1. 暴力法

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int max_val = INT_MIN;
        for (int i = 0; i < nums.size(); i++) {
            int sum = 0;
            for (int j = i; j < nums.size(); j++) {
                sum += nums[j];
                max_val = max(max_val, sum);
            }
        }
        return max_val;
    }
};
```

2. 前缀和
- 把两个边界移动变为一个边界移动，从求子数组的最大和变为求两个前缀和的差。
- 假设一个数组 nums，其前缀和数组为 prefixSum，那么 prefixSum[i] 表示从 nums[0] 到 nums[i-1] 的元素和。
- 求两个前缀和的差最大

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        if (n == 0) return 0;

        // 步骤1：计算前缀和数组
        vector<int> prefixSum(n + 1, 0);
        for (int i = 1; i <= n; ++i) {
            prefixSum[i] = prefixSum[i - 1] + nums[i - 1];
        }

        // 步骤2：遍历前缀和数组，找出最大子数组和
        int minPrefixSum = 0;
        int maxSubArraySum = INT_MIN;
        for (int i = 1; i <= n; ++i) {
            // 当前子数组和为 prefixSum[i] - minPrefixSum
            maxSubArraySum = max(maxSubArraySum, prefixSum[i] - minPrefixSum);
            // 更新最小前缀和
            minPrefixSum = min(minPrefixSum, prefixSum[i]);
        }

        return maxSubArraySum;
    }
};
```

## 2. 合并区间

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [start[i], end[i]]` 。请你合并所有重叠的区间，并返回 _一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间_ 。

**示例 1：**

```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**示例 2：**

```
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

**提示：**

-   `1 <= intervals.length <= 10^4`
-   `intervals[i].length == 2`
-   `0 <= start[i] <= end[i] <= 10^4`

### 思路

- 遍历数组，将数组加入结果数组。
- 如果前一个数组的右值比后一个数组的左值小，不变；
    - 否则，后数组与前数组的右值的大值覆盖前数组的右值。
- 未提示有序，先排序。


```cpp
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        if (intervals.empty()) {
            return {};
        }
        
        vector<vector<int>> res;
        sort(intervals.begin(), intervals.end());

        for (auto intr : intervals) {
            if (res.empty() || res.back()[1] < intr[0])
                res.push_back(intr);
            else
                res.back()[1] = max(res.back()[1], intr[1]);
        }
        return res;
    }
};
```

## 3. 除自身以外数组的乘积

给你一个整数数组 `nums`，返回 数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积 。

题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在  **32 位** 整数范围内。

请 **不要使用除法，**且在 `O(n)` 时间复杂度内完成此题。

**示例 1:**

```
输入: nums = [1,2,3,4]
输出: [24,12,8,6]
```

**示例 2:**

```
输入: nums = [-1,1,0,-3,3]
输出: [0,0,9,0,0]
```

**提示：**

-   `2 <= nums.length <= 10^5`
-   `-30 <= nums[i] <= 30`
-   **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在  **32 位** 整数范围内

**进阶：** 你可以在 `O(1)` 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组 **不被视为** 额外空间。）

### 思路

- 求第i数左右乘积
- 先用两个遍历把左右乘积都算出，再用一个遍历相乘得出结果。

```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        vector<int> answer(n, 1);
        
        // 步骤1：计算从左到右的前缀乘积
        vector<int> left(n, 1);
        for (int i = 1; i < n; i++) {
            left[i] = left[i - 1] * nums[i - 1];
        }
        
        // 步骤2：计算从右到左的前缀乘积
        vector<int> right(n, 1);
        for (int i = n - 2; i >= 0; i--) {
            right[i] = right[i + 1] * nums[i + 1];
        }
        
        // 步骤3：计算结果数组
        for (int i = 0; i < n; i++) {
            answer[i] = left[i] * right[i];
        }
        
        return answer;
    }
};
```