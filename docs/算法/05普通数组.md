---
sort: 5
---

# 普通数组

- 数组的特点是连续，长度确定，滑动窗口多适合

## 1. 最大子数组和

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组**

是数组中的一个连续部分。

**示例 1：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组[4,-1,2,1] 的和最大，为6 。
```

**示例 2：**

```
输入：nums = [1]
输出：1
```

**示例 3：**

```
输入：nums = [5,4,-1,7,8]
输出：23
```

**提示：**

-   `1 <= nums.length <= 10^5`
-   `-10^4 <= nums[i] <= 10^4`

**进阶：** 如果你已经实现复杂度为 `O(n)` 的解法，尝试使用更为精妙的 **分治法** 求解。


### 思路
- 连续和遍历 想到 滑动窗口
- 快慢指针遍历，快慢指针都到底才结束


1. 暴力法

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int max_val = INT_MIN;
        for (int i = 0; i < nums.size(); i++) {
            int sum = 0;
            for (int j = i; j < nums.size(); j++) {
                sum += nums[j];
                max_val = max(max_val, sum);
            }
        }
        return max_val;
    }
};
```

2. 前缀和
    1. 首先计算数组的前缀和数组 `prefixSum`，其中 `prefixSum[i]` 表示 `nums[0]` 到 `nums[i]` 的和。
    2. 遍历所有可能的子数组区间，对于每个区间 `[i, j]`，子数组和为 `prefixSum[j] - prefixSum[i - 1]`（当 `i == 0` 时，子数组和就是 `prefixSum[j]`）。
    3. 在遍历过程中不断更新最大子数组和。

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> prefixSum(n + 1, 0);
        for (int i = 1; i <= n; i++) {
            prefixSum[i] = prefixSum[i - 1] + nums[i - 1];
        }
        int maxSum = nums[0];
        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                int subarraySum = prefixSum[j + 1] - prefixSum[i];
                maxSum = max(maxSum, subarraySum);
            }
        }
        return maxSum;
    }
};
```

这种解法的时间复杂度为 $O(n^2)$，因为有两层循环遍历子数组的起始和结束位置。空间复杂度为 $O(n)$，用于存储前缀和数组。相比动态规划和贪心解法，这种前缀和解法效率较低，但它提供了一种不同的思考角度。

## 2. 合并区间

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [start[i], end[i]]` 。请你合并所有重叠的区间，并返回 _一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间_ 。

**示例 1：**

```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**示例 2：**

```
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

**提示：**

-   `1 <= intervals.length <= 10^4`
-   `intervals[i].length == 2`
-   `0 <= start[i] <= end[i] <= 10^4`

### 思路

1. 排序
   - 首先对给定的区间数组按照区间的起始位置进行排序。这样可以确保相邻的区间在起始位置上具有一定的顺序。
2. 遍历合并
   - 初始化一个结果数组，将第一个区间放入结果数组中。
   - 从第二个区间开始遍历所有区间：
     - 如果当前区间的起始位置小于等于结果数组中最后一个区间的结束位置，说明有重叠，更新结果数组中最后一个区间的结束位置为当前区间和结果数组中最后一个区间结束位置的较大值。
     - 如果当前区间与结果数组中最后一个区间不重叠，将当前区间加入结果数组。

```cpp
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        if (intervals.empty()) return {};
        // 按照区间的起始位置进行排序
        sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b) {
            return a[0] < b[0];
        });
        vector<vector<int>> merged;
        merged.push_back(intervals[0]);
        for (int i = 1; i < intervals.size(); i++) {
            if (intervals[i][0] <= merged.back()[1]) {
                merged.back()[1] = max(merged.back()[1], intervals[i][1]);
            } else {
                merged.push_back(intervals[i]);
            }
        }
        return merged;
    }
};
```

这个解法的时间复杂度主要取决于排序操作，通常为 $O(n log n)$，其中 $n$ 是区间的数量。遍历区间的操作是线性的，时间复杂度为 $O(n)$。所以总体时间复杂度为 $O(n log n)$。空间复杂度取决于结果数组的大小，在最坏情况下，所有区间都不重叠，结果数组的大小与输入数组相同，所以空间复杂度为 $O(n)$。

## 3. 除自身以外数组的乘积

给你一个整数数组 `nums`，返回 数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积 。

题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在  **32 位** 整数范围内。

请 **不要使用除法**，且在 `O(n)` 时间复杂度内完成此题。

**示例 1:**

```
输入: nums = [1,2,3,4]
输出: [24,12,8,6]
```

**示例 2:**

```
输入: nums = [-1,1,0,-3,3]
输出: [0,0,9,0,0]
```

**提示：**

-   `2 <= nums.length <= 10^5`
-   `-30 <= nums[i] <= 30`
-   **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在  **32 位** 整数范围内

**进阶：** 你可以在 `O(1)` 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组 **不被视为** 额外空间。）

### 思路

- 求第i数左右乘积
- 先用两个遍历把左右乘积都算出，再用一个遍历相乘得出结果。

```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        vector<int> answer(n, 1);
        
        // 步骤1：计算从左到右的前缀乘积
        vector<int> left(n, 1);
        for (int i = 1; i < n; i++) {
            left[i] = left[i - 1] * nums[i - 1];
        }
        
        // 步骤2：计算从右到左的前缀乘积
        vector<int> right(n, 1);
        for (int i = n - 2; i >= 0; i--) {
            right[i] = right[i + 1] * nums[i + 1];
        }
        
        // 步骤3：计算结果数组
        for (int i = 0; i < n; i++) {
            answer[i] = left[i] * right[i];
        }
        
        return answer;
    }
};
```