---
sort: 6
---

# 断言与异常

程序错误通常分为两类：
- 编程错误导致的逻辑错误。例如，“索引超出范围”错误。
- 超出程序员控制的运行时错误。例如，“网络服务不可用”错误。

传统C语言错误报告的方式：
- 返回一个表示错误代码或特定函数的状态代码的值。
- 设置一个全局变量，调用方可以在每次执行函数调用后选择性地检索该变量来查看是否报告了错误。

C++ 中优先使用异常的原因如下：
- 异常会强制调用代码识别并处理错误状态。未经处理的异常会停止程序执行。
- 异常跳转到调用堆栈中可以处理错误的位置。中间函数可以让异常传播。这些函数不必与其他层协调。
- 引发异常后，异常堆栈展开机制将根据妥善定义的规则销毁范围内的所有对象。
- 异常可以在检测错误的代码与处理错误的代码之间实现明确的分离。

```c++
#include <stdexcept>
#include <limits>
#include <iostream>

using namespace std;

void MyFunc(int c)
{
    if (c > numeric_limits< char> ::max())
    {
        throw invalid_argument("MyFunc argument too large.");
    }
    //...
}

int main()
{
    try
    {
        MyFunc(256); //cause an exception to throw
    }

    catch (invalid_argument& e)
    {
        cerr << e.what() << endl;
        return -1;
    }
    //...
    return 0;
}
```

异常与断言
- 异常和断言是用于检测程序中运行时错误的两种不同机制。如果所有代码都正确，可以使用 assert 语句来测试开发过程中始终应为 true 或 false 的条件。使用异常来处理此类错误是没有意义的，因为错误指示的是代码中必须修复的问题。它并不表示程序在运行时必须从中恢复的状态。
- assert 在语句中停止执行，以便可以在调试器中检查程序状态。异常从第一个适当的 catch 处理程序继续执行。即使代码正确，也可以使用异常来检查在运行时可能发生的错误状态，例如“找不到文件”或“内存不足”。异常可以处理这些状态，即使恢复只是将消息输出到日志并结束程序。

基本准则
- 使用断言检查应始终为 true 或始终为 false 的条件，例如公共函数参数的输入验证错误。
- 当处理错误的代码与通过一个或多个中间函数调用检测错误的代码分离时，请使用异常。当处理错误的代码与检测错误的代码紧密耦合时，请考虑是否在性能关键型循环中使用错误代码。
- 对于每个可能引发或传播异常的函数，请提供三项异常保证之一：强保证、基本保证或 nothrow (noexcept) 保证。
- 通过值引发异常，通过引用捕获异常。不要捕获无法处理的异常。
- 不要使用 C++11 中已弃用的异常规范。有关详细信息，请参阅异常规范和 noexcept 部分。
- 使用适用的标准库异常类型。从 exception 类层次结构派生自定义的异常类型。
- 不要允许异常从析构函数或内存解除分配函数中逃逸。