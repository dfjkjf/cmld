---
sort: 3
---

# C++模板

C++ 中的模板是一项强大的功能，允许您编写通用代码，这意味着您可以编写处理不同数据类型的单个函数或类，而不需要为要使用的每种数据类型编写单独的函数或类。

1. 模板函数

要创建模板函数，请使用 template 关键字，后跟用尖括号括起来的类型参数或占位符 ( < > )。然后，您可以像平常一样定义函数，使用类型参数来指定泛型类型。

```c++
template <typename T>
T max(T a, T b) {
    return (a > b) ? a : b;
}

int result = max<int>(10, 20);
```

2. 模板类

当多个线程访问共享资源时，可能会出现数据竞争。为了避免这种情况，请使用互斥锁和锁来同步共享资源访问。
```c++
template <typename T1, typename T2>
class Pair {
public:
    T1 first;
    T2 second;

    Pair(T1 first, T2 second) : first(first), second(second) {
        std::cout << "Generic container." << std::endl;
    }
};

Pair<int, std::string> pair(1, "Hello");
```

3. 模板专业化

模板专门化是一种针对特定类型或一组类型自定义或修改模板行为的方法。当您想要优化行为或为某种类型提供特定实现而不影响其他类型模板的整体行为时，这可能很有用。有两种主要方法可以专门化模板：
- 完全专业化：当您为特定类型或类型集提供特定实现时，就会发生这种情况。
- 部分专业化：当您为匹配特定模式或条件的类型子集提供更通用的实现时，就会发生这种情况。

```c++
// Primary template
template <typename T>
class MyTemplate {
    const char* name() {
        return "General case";
    }
};

// Partial specialization for pointers
template <typename T>
class MyTemplate<T*> {
    const char* name() {
        return "Partial specialization for pointers";
    }
};

// Full specialization for int
template <>
class MyTemplate<int> {
    const char* name() {
        return "Full specialization for int";
    }
};

int main() {
    MyTemplate<double> t1; // General case
    MyTemplate<double*> t2; // Partial specialization for pointers
    MyTemplate<int> t3; // Full specialization for int

    std::cout << t1.name() << std::endl;
    std::cout << t2.name() << std::endl;
    std::cout << t3.name() << std::endl;

    return 0;
}
```
运行此示例时，输出将是：
```bash
General case
Partial specialization for pointers
Full specialization for int
```

4. 可变参数模板

当您需要编写可以接受不同数量和类型的参数的函数或类时，这特别有用。

可变参数模板的语法非常简单。要定义可变参数模板，请使用 ... （省略号）表示法：
```c++
template <typename... Args>
```
此表示法表示参数包，它可以包含零个或多个参数。您可以在模板定义中使用此参数包作为模板参数的变量列表。
```c++
#include <iostream>

// Base case for recursion
template <typename T>
T sum(T t) {
  return t;
}

// Variadic template
template <typename T, typename... Args>
T sum(T t, Args... args) {
  return t + sum(args...);
}

int main() {
  int result = sum(1, 2, 3, 4, 5);  // expands to 1 + 2 + 3 + 4 + 5
  std::cout << "The sum is: " << result << std::endl;

  return 0;
}
```
```c++
template <typename... Types>
class Tuple;

// Base case: empty tuple
template <>
class Tuple<> {};

// Recursive case: Tuple with one or more elements
template <typename Head, typename... Tail>
class Tuple<Head, Tail...> : public Tuple<Tail...> {
 public:
  Tuple(Head head, Tail... tail) : Tuple<Tail...>(tail...), head_(head) {}

  Head head() const { return head_; }

 private:
  Head head_;
};

int main() {
  Tuple<int, float, double> tuple(1, 2.0f, 3.0);
  std::cout << "First element: " << tuple.head() << std::endl;
  return 0;
}
```

5. 类型特征

类型特质（Traits）是 C++ 中的一组模板类，有助于获取有关类型的属性、行为或特征的信息。它们可以在 \<type_traits\> 头文件中找到。通过使用类型特质，你可以根据给定类型的属性调整代码，甚至在模板代码中为类型参数强制执行特定属性。常见的类型特征是：
- `std::is_pointer` ：检查给定类型是否是指针类型。
- `std::is_arithmetic` ：检查给定类型是否为算术类型。
- `std::is_function` ：检查给定类型是否是函数类型。
- `std::decay` ： 对输入类型应用 decltype 规则（删除引用、cv-限定符等）。
```c++
#include <iostream>
#include <type_traits>

int main() {
    int a;
    int* a_ptr = &a;

    std::cout << "Is 'a' a pointer? " << std::boolalpha << std::is_pointer<decltype(a)>::value << std::endl;
    std::cout << "Is 'a_ptr' a pointer? " << std::boolalpha << std::is_pointer<decltype(a_ptr)>::value << std::endl;

    return 0;
}
```

有些类型特征可以帮助您组成或修改其他特征，例如：
- `std::conditional` ：如果给定的布尔值为真，则使用 A 类型；否则，使用 B 类型。
- `std::enable_if` ：如果给定的布尔值为真，则使用 A 类型；否则，没有嵌套类型。

```c++
#include <iostream>
#include <type_traits>

template <typename T>
void find_max(T a, T b) {
    std::cout << "Called when T is not arithmetic" << std::endl;
}

template <typename T>
typename std::enable_if<std::is_arithmetic<T>::value, T>::type find_max(T a, T b) {
    return a > b ? a : b;
}

int main() {
    int max = find_max(10, 20);
    std::cout << "Max: " << max << std::endl;

    return 0;
}
```
在本例中，只有当 T 是算术类型（如 int、float、double）时，才会定义 find_max 模板函数。这样可以防止在非算术类型中意外使用 find_max 函数。
