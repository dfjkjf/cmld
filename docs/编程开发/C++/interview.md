---
sort: 1
---

# 面试

## 范围

常见提问：

### 关键字

1. **struct内存对齐问题**

内存对齐是一种优化技术，它确保访问特定类型的变量时，这些变量的内存地址是符合特定规则的。这种规则是由编译器和目标处理器架构决定的，目的是为了提高内存访问的效率。

C++中的struct类型在内存中的布局会受到内存对齐的影响。内存对齐的规则通常包括以下几点：
- 基本对齐（Fundamental Alignment）：每个基本数据类型（如int、float、double等）都有一个默认的对齐值，通常是该类型的大小。例如，一个int类型在大多数系统上的对齐值是4字节。
- 结构体对齐（Struct Alignment）：结构体本身的对齐值是结构体中最长基本类型成员的对齐值。例如，如果一个结构体中最长的成员是double（通常是8字节），那么这个结构体的对齐值也是8字节。
- 成员对齐（Member Alignment）：结构体成员的对齐值通常是成员自身类型的大小。成员的偏移量必须是其对齐值的整数倍。
- 填充（Padding）：为了满足对齐要求，编译器可能会在结构体成员之间插入未使用的空间，这称为填充。
- 数组成员对齐：数组成员的对齐值与单个元素的对齐值相同，但整个数组的起始地址必须满足结构体的对齐要求。
- 派生类对齐：在继承中，派生类的内存布局必须满足基类和派生类成员的对齐要求

2. **sizeof和strlen的区别**

| 特性 | sizeof | strlen |
|------|--------|--------|
| 类型 | 操作符 | 函数 |
| 求值时间 | 编译时 | 运行时 |
| 用途 | 确定变量或数据类型的大小（以字节为单位） | 计算字符串的长度（不包括末尾的空字符） |
| 应用对象 | 任何数据类型或变量（如 `int`、`float`、`struct` 等） | 只能用于以空字符结尾的字符串 |
| 返回值 | 类型或变量的大小 | 字符串中的字符数 |


3. **static const extern volatile mutable explicit**

| 关键字 | 目的 | 适用场景 |
|--------|------|----------|
| `static` | 用于声明静态变量或函数，其生命周期持续到程序结束，且在内存中的位置是固定的。 | - 当需要在一个函数内保持变量值在多次调用之间不变时。<br>- 当需要在类中定义一个所有对象共享的成员时。 |
| `const` | 用于声明常量，表示变量的值一旦初始化后就不能更改。 | - 当需要定义一个不会改变的变量时。<br>- 当需要确保函数不会修改传入的参数时。 |
| `extern` | 用于声明变量或函数在其他地方定义。 | - 当需要在多个文件中共享变量或函数时。<br>- 当需要在当前文件中使用其他文件中定义的变量或函数时。 |
| `volatile` | 用于声明变量，其值可能会在程序的控制之外被改变，例如由硬件或其他线程改变。 | - 当需要确保编译器不会优化变量的访问时。<br>- 当变量可能会被并发执行的线程或中断服务例程修改时。 |
| `mutable`	| 声明一个可以被修改的常量，即使该常量位于一个const对象或函数中 | - 修饰类成员，声明可变常量 |
| `explicit` | 声明显式转换，防止隐式类型转换，用于构造函数或转换函数 | - 修饰构造函数，声明显式构造函数 |

4. **4种类型转换：static_cast dynamic_cast const_cast reinterpret_cast**

| 类型转换 | 描述 | 使用场景 | 注意事项 |
|-----------|------|----------|----------|
| `static_cast` | 用于执行安全的类型转换，例如基本数据类型之间的转换，或者继承层次结构中上下转换（只要没有虚函数被覆盖）。 | - 当你知道两种类型之间可以安全转换时。<br>- 用于执行数值转换或基本数据类型转换。 | - 不适用于具有虚函数的类层次结构中的向下转换。<br>- 使用时需要确保转换的安全性。 |
| `dynamic_cast` | 用于在运行时检查和执行安全的向下转换（基类指针转换为派生类指针）和交叉转换（不同继承层次中的类之间的转换）。 | - 当你需要在一个类层次结构中安全地进行向下转换时。<br>- 用于交叉转换，以确定对象是否是目标类型的实例。 | - 只适用于指针或引用类型。<br>- 如果转换不成功，返回空指针（对于指针）或空引用（对于引用）。 |
| `const_cast` | 用于添加或移除`const`、`volatile`或`__unaligned`修饰符。 | - 当你需要临时修改一个`const`对象的值时。<br>- 用于将非`const`对象转换为`const`对象。 | - 只应用于合理的场景，如临时修改`const`对象或在函数重载时传递`const`或非`const`参数。 |
| `reinterpret_cast` | 用于执行低级转换，它可以将任何指针类型转换为任何其他指针类型，不考虑它们的原始类型。 | - 当你需要将一个指针类型转换为完全不同的指针类型时。<br>- 用于执行底层内存操作或与外部系统（如硬件接口）交互。 | - 使用非常危险，因为它可能会导致未定义的行为。<br>- 应该避免使用，除非你完全了解转换的后果。 |

4. **指针和引用的区别**

| 特性 | 指针 | 引用 |
|:----|:--------|:-----|
| 定义和语法 | 指针是一个变量，其值是另一个变量的地址。声明时使用星号 `*`。例如：`int *ptr;` | 引用是变量的别名，实际上是另一个变量的另一个名称。声明时使用 ampersand `&`。例如：`int &ref = var;` |
| 内存地址 | 指针本身有内存地址，并且可以存储其他变量的地址。| 引用本身不是对象，没有自己的内存地址，它是另一个变量的别名。|
| 赋值和重新指向 | 指针可以被重新赋值，指向不同的变量。例如：`ptr = &anotherVar;` | 引用一旦初始化后，始终指向最初初始化的变量，不能更改引用的指向。 |
| 空值 | 指针可以存储空值（`nullptr` 或 `NULL`），表示不指向任何对象。 | 引用必须始终引用一个有效的对象，不能为空。 |
| 解引用 | 必须使用解引用运算符 `*` 来访问指针所指向的值。 | 可以直接使用引用来访问所引用的值，不需要解引用运算符。 |
| 指针运算 | 可以进行指针运算，如自增 `++`、自减 `--`、指针加法等，用于访问内存中的不同位置。 | 不能进行任何形式的运算。 |
| 函数参数 | 可以作为函数参数传递，用于修改实参或者传递空值。 | 可以作为函数参数传递，用于修改实参，但不能传递空值。 |
| 多维数组 | 可以用来访问多维数组，通过指针的算术运算来计算数组元素的地址。 | 不能直接用于访问多维数组，因为引用不是一个可变的地址。 |

5. **有了指针为何还要引用**

| 优点 | 说明 |
|------|------|
| 安全性 | 引用必须始终引用一个有效的对象，减少了空指针检查的需求，并且不会产生悬挂指针问题 |
| 代码简化 | 引用不需要使用解引用运算符 `*`，使得代码更加简洁和易于阅读 |
| 性能 | 传递引用可以避免对象的拷贝，节省时间和资源，并保证函数内部直接操作原始对象 |
| 函数重载 | 引用可以用来区分重载函数的参数类型，提供更直观的接口 |
| 操作符重载 | 引用在操作符重载中经常被用作参数类型，以直接操作操作数的值 |
| 常量性 | 引用可以用来指定常量引用，允许以只读方式访问对象，保证对象不会被修改 |
| API设计 | 在设计库或API时，引用可以提供更直观的接口，减少用户错误，使得API更容易理解和正确使用 |

6. **内存分区：堆区、栈区、全局区、常量区、代码区**

在C++中，程序的内存被分为几个不同的区域，每个区域都有其特定的用途和生命周期。以下是主要的内存分区：
| 内存分区 | 描述 | 使用场景 | 特点 |
|----------|------|----------|------|
| 栈区（Stack） | 用于存储局部变量和函数调用的上下文信息。 | - 局部变量<br>- 函数参数和返回值 | - 自动分配和释放<br>- 有限大小<br>- 快速访问 |
| 堆区（Heap） | 用于动态分配的内存，由程序员控制。 | - 动态分配的对象<br>- 数组（当大小在编译时未知） | - 手动分配和释放<br>- 大小灵活<br>- 访问速度较慢 |
| 全局区（Data） | 用于存储全局变量和静态局部变量。 | - 全局变量<br>- 静态局部变量 | - 程序启动时分配，程序结束时释放<br>- 生命周期与程序相同 |
| 常量区（Constant） | 用于存储常量值，如字符串字面量和const变量。 | - 字符串字面量<br>- const变量 | - 只读<br>- 程序启动时分配，程序结束时释放 |
| 代码区（Code） | 用于存储程序的代码，包括可执行指令和只读数据。 | - 函数体<br>- 字面量代码 | - 只读<br>- 程序启动时加载，程序结束时卸载 |

7. **C++栈和堆的区别，为何栈比堆块**

| 特性 | 栈 (Stack) | 堆 (Heap) |
|------|------------|-----------|
| 内存管理 | 编译器自动管理 | 程序员手动管理 |
| 性能 | 高（快速分配和释放） | 较低（较慢的分配和释放） |
| 用途 | 局部变量、函数参数 | 动态数据、对象、数组 |
| 生命周期 | 自动（与函数调用周期相同） | 手动（直到被显式释放） |
| 大小限制 | 通常有限 | 理论上只受系统内存限制 |
| 缓存友好性 | 高 | 低 |
| 访问速度 | 快 | 慢 |
| 硬件支持 | 有专门寄存器和指令优化 | 没有专门硬件优化 |
| 分配方式 | 后进先出（LIFO） | 灵活分配和释放 |
| 碎片管理 | 几乎没有碎片 | 可能需要内存碎片整理 |

8. **A.so调用B.so的方法，A是如何找到的**
- 编译阶段：A.so在编译时可能不知道B.so中方法的实际地址，因为它可能会在不同的地址空间中加载。因此，A.so通常会包含对B.so中方法的符号引用，而不是直接的地址。
- 运行阶段：当A.so被加载到内存中时，操作系统的动态链接器会负责解析这些符号引用。一旦符号被解析，动态链接器会将B.so中方法的实际地址写入A.so中的符号表，从而完成地址绑定。这样，当A.so中的代码调用这些方法时，它会使用B.so中的实际地址。

### 面向对象

1. **C++结构体和类的区别**

类相较结构体：增加了权限、构造/析构函数、成员函数、继承。

2. **面向对象的三大特性**

| 面向对象的三大特性 | 描述 |
|-----------------|------|
| 封装（Encapsulation） | 隐藏类的内部实现细节，对外只提供接口。 |
| 继承（Inheritance） | 允许类之间共享属性和方法，通过派生类继承基类的特性。 |
| 多态（Polymorphism） | 允许使用基类指针或引用调用派生类的函数，实现运行时动态绑定。 |

3. **类的访问权限：public、protected、private**

| 访问权限 | 描述 | 子类继承 |
|----------|------|----------|
| public | 公共成员对所有代码都是可见的。 | 子类可以访问和修改公共成员。 |
| protected | 保护成员对类的所有成员函数和友元是可见的。 | 子类可以访问和修改保护成员，但不能直接访问私有成员。 |
| private | 私有成员对除了类的成员函数和友元之外的所有代码都是不可见的。 | 子类不能访问或修改私有成员。 |

4. **类的构造函数、析构函数、赋值函数、拷贝函数**

在C++中，类自带的函数主要包括以下几种：
- **构造函数**：用于创建对象时初始化类的成员变量。每个类都可以有一个或多个构造函数，可以是默认构造函数、复制构造函数、移动构造函数等。
- **析构函数**：用于销毁对象时清理资源。每个类至少有一个析构函数，如果没有显式定义，编译器会自动生成一个默认的析构函数。
- **复制构造函数**：用于创建一个新对象，其初始值与另一个同类对象相同。当使用一个已存在的对象初始化一个新对象时，会调用复制构造函数。
- **复制赋值运算符**：用于将一个对象的值赋给另一个对象。当一个对象被另一个同类对象赋值时，会调用复制赋值运算符。
- **移动构造函数**：用于创建一个新对象，并将另一个同类对象的资源移动到新对象中。移动构造函数在移动操作中使用，如`std::unique_ptr`的移动。
- **移动赋值运算符**：用于将一个对象的资源移动到另一个对象中。移动赋值运算符在移动操作中使用，如`std::unique_ptr`的移动赋值。
- **成员函数重载**：允许在类中定义多个同名函数，但参数列表不同，这样可以提高代码的可读性和灵活性。
- **静态成员函数**：不依赖于任何对象实例，可以直接通过类名调用。静态成员函数可以访问静态成员变量。
- **友元函数**：允许外部函数访问类的私有成员和保护成员。友元函数不是类的成员，但可以像类的成员函数一样访问类的内部数据。
- **运算符重载**：允许重定义运算符，以支持自定义类型或数据结构。运算符重载可以定义为成员函数或非成员函数。

**移动构造函数**和**移动赋值运算符**通常被声明为`noexcept`，以便编译器在需要保证不抛出异常的情况下优化这些操作。

5. **重载**和**重写**的区别

- **重载（overload）**：
    - 重载发生在同一个类内部，或者在同一作用域内，当有两个或多个方法具有相同的名字，但是参数列表不同（参数的数量、类型或者参数的顺序不同）时，这些方法被认为是重载的。
    - 重载是编译时多态（静态多态）的一个例子，因为调用哪个方法是在编译时根据方法签名决定的。
    - 重载的方法可以有不同的返回类型，但是返回类型本身不足以区分重载的方法，必须要有参数列表的不同。
- **重写（override）**：
    - 重写发生在基类和派生类之间。当一个派生类有一个与基类同名的方法，并且这个方法的参数列表相同（或者兼容（意味着派生类中的方法的参数类型应该是基类中方法参数类型的子类型）），那么派生类的方法被认为重写了基类的方法。
    - 重写是运行时多态（动态多态）的一个例子，因为调用哪个方法是在运行时根据对象的实际类型决定的。
    - 重写的方法必须有相同或者子类型的返回类型（ covariance ），这意味着派生类重写方法的返回类型可以是基类方法的返回类型的子类型。
    - 要实现重写，基类的方法通常需要被声明为虚方法（使用 `virtual` 关键字），在C++11之后，可以使用 `override` 关键字显式地表明重写的意图。

6. **虚函数和纯虚函数的区别**

| 特性 | 虚函数 | 纯虚函数 |
|------|--------|----------|
| 定义 | 在基类中可以有一个默认的实现，也可以在派生类中被覆盖 | 在基类中没有具体的实现，只有函数声明，并且必须在派生类中被覆盖 |
| 语法 | 在函数声明后加上 `virtual` 关键字 | 在函数声明后加上 `= 0` |
| 实例化 | 可以有实例化的对象 | 所在的类称为抽象类，不能直接实例化。必须先被派生类覆盖后，通过派生类的对象来实例化 |
| 目的 | 提供一种在运行时动态绑定函数调用的机制，使得基类指针或引用可以调用派生类的函数 | 定义一个接口，强制派生类提供特定的实现。它用于表示抽象类和抽象行为 |
| 使用场景 | 当你希望基类提供默认行为，但允许派生类修改或扩展该行为时使用 | 当你希望定义一个接口，但不提供任何具体的实现，要求派生类必须实现该函数时使用 |
| 继承 | 派生类可以继承基类的虚函数，可以选择覆盖或不覆盖 | 派生类必须覆盖基类的纯虚函数，否则派生类也将成为抽象类 |

7. **多态的意义**

是的，在C++中，多态性可以分为两种主要形式：静态多态和动态多态。
- 静态多态（编译时多态）：
   - 静态多态是在编译时确定函数调用的多态形式。
   - 它主要通过**函数重载**和**模板**来实现。
   - 函数重载允许在同一作用域内声明多个同名函数，但它们的参数列表必须不同。编译器根据提供的参数类型和数量来确定调用哪个函数。
   - 模板允许编写与类型无关的代码，编译器会为使用模板的每个具体类型生成不同的函数版本。
- 动态多态（运行时多态）：
   - 动态多态是在程序运行时确定函数调用的多态形式。
   - 它主要通过**虚函数**和**继承**来实现。
   - 虚函数是在基类中使用关键字 `virtual` 声明的函数，它们可以在派生类中被**重写**。
   - 当通过基类的指针或引用调用虚函数时，实际调用的函数版本取决于指针或引用所指向的对象的实际类型（即派生类类型）。
   - 这种在运行时根据对象的实际类型来决定调用哪个函数版本的过程称为动态绑定或晚期绑定。

8. **虚函数表**

虚函数表（Virtual Function Table，通常缩写为 vtable）是 C++ 语言中用于实现运行时多态的一种机制。虚函数表是一个数组，其中每个元素都是一个函数指针，指向类的虚函数的地址。

虚函数表是针对类的，一个类的所有对象的虚函数表都一样。无论创建了多少个类的实例，它们都共享同一个虚函数表。当通过基类指针或引用调用虚函数时，C++运行时使用对象的vptr来确定要调用的函数版本，这确保了多态的正确实现。

这个表在程序的只读数据段中创建。当类的对象被创建时，对象的隐藏成员 vptr（虚函数指针）会被设置为指向该类的虚函数表。这样，当通过基类指针或引用调用虚函数时，程序可以通过 vptr 找到正确的虚函数表，并调用相应地址的函数，从而实现多态。

9. **菱形继承**

菱形继承问题是指当一个类继承了两个或多个基类，而这些基类之间又存在继承关系时，可能会导致内存布局和析构顺序的问题。通过**虚继承**，可以确保所有派生类共享基类的同一实例。

### 模板

1. **什么是模板？**
   - 模板是一种编程范式，它允许你编写可以适用于不同数据类型的代码。模板是泛型编程的核心，使得代码更加灵活和可重用。
2. **模板的类型有哪些？**
   - C++中的模板主要分为两类：函数模板和类模板。
     - 函数模板：允许编写可以接受不同类型参数的函数。
     - 类模板：允许编写可以适用于不同类型成员的类。
3. **模板参数有哪些类型？**
   - C++中的模板参数有三种类型：
     - 类型参数：可以用来指定模板可以适用的数据类型。
     - 非类型参数：可以用来指定模板可以适用的其他类型的参数，如整数、枚举等。
     - 模板模板参数：可以用来指定模板可以适用的其他模板。
4. **模板参数推导是什么？**
   - 模板参数推导是一种编译器特性，它允许编译器根据传入的参数自动推导出模板参数的类型。这使得编写泛型代码变得更加简单和直观。
5. **什么是模板特化？**
   - 模板特化是指为特定数据类型提供特定的模板实现。通过模板特化，可以提供针对特定类型的优化或特定行为的实现。
6. **什么是模板的显式实例化？**
   - 模板的显式实例化是指手动指定模板参数的值，并创建模板的实例。这通常用于在编译时确定模板的参数，而不是在运行时确定。
7. **模板是如何进行参数匹配的？**
   - 模板参数匹配是基于模板参数的类型和值来进行的。编译器会尝试将传入的参数与模板参数进行匹配，以确定是否可以应用模板。
8. **什么是模板的成员模板？**
   - 模板的成员模板是指类模板的成员函数或成员变量也可以是模板。成员模板使得类模板可以提供更加灵活和可重用的代码。
9. **如何编写模板的友元函数？**
   - 模板的友元函数是指可以访问模板类中的私有和受保护成员的函数。通过编写模板的友元函数，可以提供更加灵活和可重用的代码。
10. **如何使用模板来编写可扩展的代码？**
    - 通过编写模板，可以创建可扩展的代码，允许后续添加新的数据类型或行为，而不需要修改现有代码。
了解这些问题的答案可以帮助你更好地理解模板的概念，并在面试中展现出你的C++编程水平。

### 智能指针

1. **c++智能指针为何能不主动释放**

C++智能指针（如std::unique_ptr, std::shared_ptr和std::weak_ptr）是RAII（Resource Acquisition Is Initialization）的一个例子，它们通过在构造函数中获取资源（在本例中是指针指向的内存），并在析构函数中释放资源，来自动管理动态分配的内存。这意味着，当智能指针超出作用域时，它的析构函数会被自动调用，从而自动释放它所管理的内存。

2. **std::shared_ptr如何知道自己当前这个类被引用次数加1、减1呢**

std::shared_ptr 通过引用计数来跟踪有多少个 shared_ptr 实例共享同一个对象。引用计数的变化确实发生在构造函数、复制构造函数、赋值运算符和析构函数中，这些函数会调用特殊的原子操作函数来增加或减少引用计数，以确保在多线程环境中引用计数的更新是安全的。下面是每个情况下引用计数如何变化的详细说明：
- **构造函数**：当创建一个新的 `std::shared_ptr` 时，它会将引用计数设置为 1。
- **复制构造函数**：当使用一个已有的 `std::shared_ptr` 来构造一个新的 `shared_ptr` 时，复制构造函数会将原有 `shared_ptr` 的引用计数增加 1。
- **赋值运算符**：当给一个已有的 `std::shared_ptr` 赋值时，首先减少原有对象的引用计数，然后增加新对象的引用计数。如果赋值操作导致引用计数变为零，那么原有的对象会被销毁。
- **析构函数**：当一个 `std::shared_ptr` 被销毁时，它的析构函数会减少其所管理对象的引用计数。如果引用计数变为零，那么 `shared_ptr` 会负责销毁对象，并释放相关资源（例如，如果使用了自定义删除器，它会调用删除器）。

3. **如果在一个函数参数中以值的形式传入std::shared_ptr，那么它的引用计数是如何变化的**

当以值的形式传入 std::shared_ptr 作为函数参数时，实际上是将 shared_ptr 复制到函数的形参中。这会涉及到 shared_ptr 的复制构造函数，引用计数会相应地增加。当函数返回时，函数内的 shared_ptr 形参会被销毁。形参的析构函数会将引用计数减少 1。因此，传入函数的 shared_ptr 的引用计数在函数调用期间会增加，然后在函数返回时减少。这个过程是自动的，由 shared_ptr 的内部机制管理。

4. **利用锁的形式解决多线程问题有什么问题，不用锁可以实现线程安全吗**

使用锁来解决多线程问题是常见的做法，因为锁可以提供互斥访问，确保在同一时刻只有一个线程可以访问共享资源。然而，使用锁也存在一些问题和挑战：
- **死锁**：当两个或多个线程互相等待对方持有的锁时，可能会导致死锁，从而使程序挂起。
- **竞态条件**：即使使用了锁，如果锁的使用不当，仍然可能发生竞态条件，尤其是在锁的保护范围不正确或者锁的保护不够严格时。
- **性能开销**：锁的操作通常会有性能开销，因为它们需要操作系统进行上下文切换和调度。
- **复杂性**：使用锁会增加代码的复杂性，使得代码更难理解和维护。
- **锁粒度**：锁的粒度需要仔细考虑。过粗的锁可能会导致性能瓶颈，而过细的锁则可能导致复杂性和死锁问题。

尽管使用锁存在这些问题，但在许多情况下，锁是实现线程安全的必要手段。不过，确实存在一些无锁编程技术，可以避免使用锁而实现线程安全，例如：
- **原子操作**：许多现代处理器提供了原子操作指令，这些指令可以保证对某个内存位置的读写操作是原子的，不可中断的。例如，C++11引入了原子操作库，如 `std::atomic`，可以用来实现无锁的数据结构。
- **内存模型**：C++11引入了强内存模型，它提供了一系列的内存顺序保证，允许开发者通过指定内存访问的顺序来避免数据竞争，从而实现无锁编程。
- **锁自由数据结构**：一些数据结构如锁自由队列、锁自由堆等，它们的设计避免了使用锁，而是依赖于原子操作和内存屏障来保证线程安全。
- **软件事务内存（STM）**：STM是一种编程模型，它允许代码块在事务中执行，如果事务成功，则所有的修改会一次性提交，如果事务失败，则所有的修改会回滚，从而避免了锁的使用。

5. **std::sharedptr是线程安全吗**

`std::shared_ptr` 的引用计数机制是线程安全的，但是它的接口并不保证线程安全。这意味着，如果你在多线程环境中使用 `std::shared_ptr`，你需要自己确保线程安全。

例如，如果多个线程同时尝试创建或销毁 `std::shared_ptr`，或者多个线程同时访问 `std::shared_ptr` 所管理的资源，可能会导致竞态条件和其他同步问题。
为了解决这个问题，你可以采取以下措施：
- 使用 `std::mutex` 来保护对 `std::shared_ptr` 的访问，确保在多线程环境下只有单个线程可以修改引用计数。
- 避免在多个线程之间共享 `std::shared_ptr`，或者确保所有的 `std::shared_ptr` 操作都由单个线程执行。

6. 3种智能指针及底层实现：unique_prt shared_ptr weak_ptr

| 智能指针类型 | 特点 | 底层实现 |
| --- | --- | --- |
| unique_ptr | - 独占所指向的对象<br>- 不支持复制和赋值操作<br>- 可以通过`std::move`转移所有权 | - 通常通过一个裸指针和一个自定义的删除器实现<br>- 删除器默认为`std::default_delete`，也可以自定义<br>- 使用`std::unique_ptr`的类需要重载`operator->`和`operator*` |
| shared_ptr | - 允许多个`shared_ptr`共享同一对象<br>- 通过引用计数来管理对象的生命周期<br>- 当引用计数为0时，自动释放对象 | - 内部包含一个裸指针和一个控制块（control block）<br>- 控制块包含引用计数、弱引用计数和自定义的删除器等信息<br>- 使用原子操作来保证引用计数的线程安全性 |
| weak_ptr | - 本身不拥有资源，用于解决`shared_ptr`可能产生的循环引用问题<br>- 不影响对象的引用计数<br>- 可以通过`lock()`方法获取`shared_ptr` | - 内部包含一个`shared_ptr`和一个弱引用计数<br>- 当`shared_ptr`的引用计数为0时，`weak_ptr`也会自动失效<br>- 使用原子操作来保证弱引用计数的线程安全性 |

以下是一个伪代码示例，展示了如何使用`weak_ptr`来打破`shared_ptr`可能产生的循环引用问题：
```cpp
// 假设有两个类A和B，它们通过指针相互引用
class A {
    shared_ptr<B> bptr;
public:
    void setB(shared_ptr<B> b) {
        bptr = b;
    }
    // ... 其他成员函数 ...
};

class B {
    weak_ptr<A> aptr; // 使用weak_ptr避免循环引用
public:
    void setA(shared_ptr<A> a) {
        aptr = a;
    }
    shared_ptr<A> getA() {
        return aptr.lock(); // 返回shared_ptr，如果A还存在的话
    }
    // ... 其他成员函数 ...
};

// 在使用时
shared_ptr<A> aptr(new A());
shared_ptr<B> bptr(new B());

// 设置相互引用
aptr->setB(bptr);
bptr->setA(aptr);

// 当A和B不再需要时，它们的引用计数会减少
// 如果没有weak_ptr，这里会产生循环引用，引用计数不会降到0，导致内存泄漏
// 由于B中使用的是weak_ptr，它不会影响A的引用计数
// 当aptr被销毁时，A的引用计数减少到0，A会被销毁
// A销毁后，B中的weak_ptr自动失效，不会尝试访问已经销毁的A
```
类A有一个指向类B的shared_ptr，而类B有一个指向类A的weak_ptr。这样，当A和B相互引用时，不会形成循环引用，因为weak_ptr不会增加引用计数。当没有其他shared_ptr指向A时，A会被销毁，然后B中的weak_ptr会自动检测到A已经不存在，从而避免了悬挂指针的问题。

以下是一个伪代码示例，展示了如何使用`weak_ptr`来观察对象而不影响其生命周期：
```cpp
// 假设有一个类Observable，它表示可以被观察的对象
class Observable {
    // ... 类的实现 ...
};
// 假设有一个类Observer，它表示观察者
class Observer {
    weak_ptr<Observable> observable; // 使用weak_ptr来观察对象
public:
    void observe(shared_ptr<Observable> obj) {
        observable = obj;
    }
    void update() {
        shared_ptr<Observable> obj = observable.lock(); // 尝试获取shared_ptr
        if (obj) {
            // 如果Observable对象还存在，则执行更新操作
            // ... 执行更新逻辑 ...
        } else {
            // 如果Observable对象已经不存在，则不做任何事情
            // ... 处理Observable对象不存在的情况 ...
        }
    }
    // ... 其他成员函数 ...
};
// 在使用时
shared_ptr<Observable> observable(new Observable());
// 创建观察者并开始观察对象
Observer observer;
observer.observe(observable);
// 当Observable对象发生改变时，可以通知Observer
// Observer会尝试更新，但如果Observable已经不存在，则不会影响其生命周期
observable->someChange(); // 假设这是一个改变Observable对象状态的方法
observer.update();
// 当不再需要Observable对象时，可以释放它
// 由于Observer中使用的是weak_ptr，它不会影响Observable的引用计数
observable.reset();
// 此时，如果再次调用observer.update()，lock()将返回空shared_ptr
// 因为Observable对象已经被销毁
```
在这个伪代码示例中，`Observer`类使用`weak_ptr`来观察`Observable`对象。这样，即使`Observer`对象存在，也不会影响`Observable`对象的生命周期。当`Observable`对象被销毁时，`weak_ptr`会自动检测到这一点，从而避免了尝试访问已经销毁的对象。这种方式使得`Observer`能够观察`Observable`对象，而不产生循环引用或影响`Observable`对象的生命周期。

### 右值引用

1. **什么是右值引用？它与左值引用有什么区别？**
   - 右值引用是一种可以绑定到临时对象的引用，它通过`&&`来声明。左值引用是绑定到非临时对象的引用，通过`&`来声明。右值引用可以延长临时对象的生命周期，而左值引用不能绑定到临时对象上。

2. **什么是移动语义？它是如何实现的？**
   - 移动语义允许资源从一个对象“移动”到另一个对象，而不是复制。这是通过右值引用来实现的，它允许我们在对象之间转移资源所有权，从而避免不必要的拷贝，提高性能。

3. **解释一下`std::move`的作用和实现原理。**
   - `std::move`是一个模板函数，它的作用是将一个对象转换为右值引用。这样，就可以对这个对象实施移动语义，而不是复制语义。实现原理是将对象转换为右值引用，使得后续的移动构造函数或移动赋值运算符可以被调用。

4. **什么是完美转发？它是如何工作的？**
   - 完美转发是指能够在函数模板中保持传入参数的左右值属性，并将它们完美地转发给其他函数。这是通过`std::forward`函数模板实现的，它利用了模板参数推导和右值引用的特性。

5. **解释一下`std::forward`的作用和实现原理。**
   - `std::forward`是一个模板函数，它的作用是保持参数的左右值属性，并将其转发给其他函数。实现原理是利用模板参数推导和右值引用，根据传入参数的左右值属性返回相应的左值引用或右值引用。

6. **在什么情况下应该使用右值引用和完美转发？**
   - 当需要实现移动语义以提高性能时，应该使用右值引用。当需要编写通用函数模板，并且希望在调用链中保持参数的左右值属性时，应该使用完美转发。

7. **如何避免返回局部变量的引用？**
   - 返回局部变量的引用会导致悬挂引用，因为局部变量在函数返回后就会被销毁。可以使用右值引用和移动语义来返回局部变量的资源，而不是返回引用。

8. **在编写模板代码时，如何确保既能处理左值又能处理右值？**
   - 使用模板参数推导和完美转发可以确保既能处理左值又能处理右值。通过模板参数推导，可以自动识别传入参数的左右值属性，并通过完美转发将这些属性保持到目标函数中。

以下是一个例子，展示了如何在编写模板代码时使用模板参数推导和完美转发来确保既能处理左值又能处理右值：
```cpp
#include <iostream>
#include <type_traits>
#include <utility>
// 一个通用打印函数，它接受任意类型的参数
template<typename T>
void printValue(T&& value) {
    std::cout << "Value: " << value << std::endl;
}
// 一个包装器函数，它使用完美转发来调用printValue
template<typename T>
void wrapper(T&& arg) {
    // 使用std::forward来保持参数的左右值属性
    printValue(std::forward<T>(arg));
}
int main() {
    int x = 42;
    // 左值引用传递
    wrapper(x); // x是左值
    // 右值引用传递
    wrapper(43); // 43是右值
    // 检查传递的值的类型
    std::cout << "Is x an lvalue? " << std::boolalpha << std::is_lvalue_reference<decltype(x)>::value << std::endl;
    std::cout << "Is 43 an rvalue? " << std::boolalpha << std::is_rvalue_reference<decltype(43)>::value << std::endl;
    return 0;
}
```
在这个例子中，`wrapper`函数接受一个通用引用参数`T&& arg`，它可以是左值也可以是右值。当`wrapper`被调用时，模板参数推导会自动识别传入参数的左右值属性。例如，当`wrapper(x)`被调用时，`x`是一个左值，而当`wrapper(43)`被调用时，`43`是一个右值。

在`wrapper`函数内部，我们使用`std::forward<T>(arg)`来完美转发参数`arg`到`printValue`函数。这样，无论`arg`是左值还是右值，`printValue`函数都会接收到相同的左右值属性，从而能够正确处理。
这个例子展示了如何在模板代码中使用完美转发来确保既能处理左值又能处理右值，同时保持参数的原始左右值属性。


### 迭代器

1. **什么是迭代器？**
   - 迭代器是一种泛化的指针，它提供了对容器中元素的访问方式。迭代器可以指向容器中的元素，并通过算术运算（如递增、递减）来遍历容器。

2. **C++中有哪些类型的迭代器？**
   - C++中定义了五种迭代器类型：
     - 输入迭代器：允许读取和遍历容器中的元素。
     - 输出迭代器：允许写入和遍历容器中的元素。
     - 前向迭代器：具有输入和输出迭代器的功能，并且可以多次遍历容器。
     - 双向迭代器：具有前向迭代器的功能，并且可以在容器中双向移动。
     - 随机访问迭代器：具有双向迭代器的功能，并且可以以任意顺序访问容器中的元素。

3. **迭代器的算术运算有哪些？**
   - 迭代器支持基本的算术运算，包括递增（`++`）、递减（`--`）、前进（`+`）、后退（`-`）以及比较（`==`、`!=`、`<`、`>`、`<=`、`>=`）。

4. **如何判断一个迭代器是否有效？**
   - 通常，有效的迭代器是指向容器中某个元素的迭代器。对于空容器，迭代器可能是一个特殊的值，如`vector`的`end()`迭代器。可以通过比较迭代器是否等于容器的`end()`迭代器来判断其是否有效。

5. **什么是迭代器的适配器？**
   - 迭代器适配器是一种特殊类型的迭代器，它接受一个基础迭代器，并提供额外的功能或行为。例如，`reverse_iterator`是一个适配器，它使得基础迭代器的递增和递减操作反转。

6. **解释一下`std::distance`和`std::advance`函数的作用。**
   - `std::distance`函数用于计算两个迭代器之间的距离。
   - `std::advance`函数用于将迭代器向前或向后移动指定的距离。

7. **如何编写一个自定义迭代器？**
   - 编写自定义迭代器通常涉及到定义迭代器的类，并提供相应的递增、递减、解引用（`operator*`）、成员访问（`operator->`）等操作。自定义迭代器需要符合C++标准库对迭代器的要求。

8. **迭代器和指针有什么区别？**
   - 迭代器是一种通用的概念，它可以用于任何容器，而指针通常用于数组或通过`new`分配的内存。迭代器可能不支持所有指针的算术运算，例如，输入迭代器只支持递增和比较操作。

### STL容器

1. **什么是STL？**
   - STL是C++标准库的一部分，它提供了一组模板类和函数，用于常见的数据结构和算法。STL包括容器、迭代器、算法和函数对象。

2. **STL中有哪些主要的容器类型？**
   - STL主要包含以下容器类型：
     - 序列容器：`vector`、`deque`、`list`、`forward_list`（C++11新增）
     - 关联容器：`set`、`multiset`、`map`、`multimap`
     - 无序关联容器（C++11新增）：`unordered_set`、`unordered_multiset`、`unordered_map`、`unordered_multimap`
     - 容器适配器：`stack`、`queue`、`priority_queue`

3. **序列容器和关联容器的区别是什么？**
   - 序列容器是按照元素插入的顺序来存储元素的，而关联容器则是按照特定的键值来存储元素，并自动排序。

4. **什么是适配器？在STL中是如何使用的？**
   - 适配器是一种设计模式，它允许一个类的接口适配另一个类的接口。在STL中，容器适配器如`stack`和`queue`，是基于其他容器（如`vector`、`deque`）实现的，提供了不同的接口。

5. **`vector`和`list`的区别是什么？**
   - `vector`是一种连续内存的序列容器，支持快速随机访问，但是在插入和删除元素时可能会慢，因为它需要移动后续元素。
      - `vector`的插入、删除、扩容操作都可能会导致原**迭代器失效**，推荐使用索引。
   - `list`是一种双向链表，支持快速插入和删除，但是不支持快速随机访问。

6. **什么时候应该使用`map`而不是`unordered_map`？**
   - 当需要元素按照特定的顺序排列时，应该使用`map`，因为它基于红黑树实现，元素是按照键值排序的。如果对顺序没有要求，且对查找性能有较高要求，可以使用`unordered_map`，它基于哈希表实现，平均情况下查找时间复杂度为O(1)。

7. **如何选择合适的STL容器？**
   - 选择容器时需要考虑数据的访问模式（随机访问、顺序访问）、插入和删除操作的频率、是否需要排序、内存使用等因素。

8. **STL容器中的迭代器失效有哪些情况？**
   - 迭代器失效通常发生在容器的元素被插入或删除时。例如，在`vector`中插入元素可能导致迭代器、指针和引用失效，因为插入操作可能引起内存重新分配。

9. **什么是STL中的空间配置器（Allocator）？**
   - 空间配置器是一个对象，它负责为STL容器分配和释放内存。STL容器使用空间配置器来获取内存，以存储容器中的元素。

10. **如何自定义STL容器的内存分配策略？**
    - 可以通过继承`allocator`类并重写其`allocate`和`deallocate`方法来自定义内存分配策略。然后，可以将自定义的分配器传递给容器构造函数。

11. **常见的STL容器操作**
- **插入和删除操作**：
   - `push_back()`：在容器的末尾添加一个元素。
   - `pop_back()`：移除容器末尾的元素。
   - `push_front()`：在容器的开头添加一个元素。
   - `pop_front()`：移除容器开头的元素。
   - `insert()`：在容器中插入一个或多个元素。
   - `erase()`：从容器中移除一个或多个元素。
- **访问和修改操作**：
   - `at()`：通过索引访问容器中的元素。
   - `front()`：访问容器开头的元素。
   - `back()`：访问容器末尾的元素。
   - `begin()`：返回容器中第一个元素的迭代器。
   - `end()`：返回容器中最后一个元素的下一个位置的迭代器。
   - `clear()`：移除容器中的所有元素。
- **容量和大小操作**：
   - `size()`：返回容器中元素的数量。
   - `empty()`：检查容器是否为空。
   - `capacity()`：返回容器当前的容量。
   - `resize()`：改变容器的大小，移除或添加元素。
- **迭代器操作**：
   - `rbegin()`：返回容器中最后一个元素的逆序迭代器。
   - `rend()`：返回容器中第一个元素的逆序迭代器的下一个位置。
   - `crbegin()`：返回容器中最后一个元素的逆序常量迭代器。
   - `crend()`：返回容器中第一个元素的逆序常量迭代器的下一个位置。
- **排序和搜索操作**：
   - `sort()`：对容器中的元素进行排序。
   - `stable_sort()`：对容器中的元素进行稳定排序。
   - `search()`：在容器中查找一个元素或子序列。
   - `binary_search()`：在有序容器中使用二分查找法查找一个元素。
- **拷贝和移动操作**：
   - `copy()`：复制一个容器中的元素到另一个容器。
   - `copy_backward()`：将一个容器中的元素复制到另一个容器的末尾。
   - `move()`：移动一个容器中的元素到另一个容器。
   - `move_backward()`：将一个容器中的元素移动到另一个容器的末尾。
- **其他操作**：
   - `swap()`：交换两个容器的内容。
   - `reserve()`：预留足够的空间以容纳指定的元素数量。
   - `shrink_to_fit()`：缩小容器的大小，使其等于其元素的数量。

11. **STL算法有哪些类型？**
   - STL算法可以分为以下几类：
     - 排序和搜索算法：如`std::sort`、`std::stable_sort`、`std::search`等。
     - 比较和计数算法：如`std::equal`、`std::count`、`std::mismatch`等。
     - 查找和替换算法：如`std::find`、`std::replace`、`std::replace_if`等。
     - 排序和元素处理算法：如`std::for_each`、`std::accumulate`、`std::partial_sum`等。
     - 迭代器算法：如`std::copy`、`std::copy_backward`、`std::rotate`等。
     - 转换和逆转换算法：如`std::transform`、`std::reverse`、`std::reverse_copy`等。
