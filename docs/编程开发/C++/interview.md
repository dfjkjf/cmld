---
sort: 1
---

# 面试

1. **C++结构体和类的区别**

类和结构体的区别：增加了权限、构造/析构函数、成员函数

2. **多态的意义**

是的，在C++中，多态性可以分为两种主要形式：静态多态和动态多态。
- 静态多态（编译时多态）：
   - 静态多态是在编译时确定函数调用的多态形式。
   - 它主要通过**函数重载**和**模板**来实现。
   - 函数重载允许在同一作用域内声明多个同名函数，但它们的参数列表必须不同。编译器根据提供的参数类型和数量来确定调用哪个函数。
   - 模板允许编写与类型无关的代码，编译器会为使用模板的每个具体类型生成不同的函数版本。
- 动态多态（运行时多态）：
   - 动态多态是在程序运行时确定函数调用的多态形式。
   - 它主要通过**虚函数**和**继承**来实现。
   - 虚函数是在基类中使用关键字 `virtual` 声明的函数，它们可以在派生类中被**重写**。
   - 当通过基类的指针或引用调用虚函数时，实际调用的函数版本取决于指针或引用所指向的对象的实际类型（即派生类类型）。
   - 这种在运行时根据对象的实际类型来决定调用哪个函数版本的过程称为动态绑定或晚期绑定。
   
3. **重载**和**重写**的区别

- **重载（overload）**：
    - 重载发生在同一个类内部，或者在同一作用域内，当有两个或多个方法具有相同的名字，但是参数列表不同（参数的数量、类型或者参数的顺序不同）时，这些方法被认为是重载的。
    - 重载是编译时多态（静态多态）的一个例子，因为调用哪个方法是在编译时根据方法签名决定的。
    - 重载的方法可以有不同的返回类型，但是返回类型本身不足以区分重载的方法，必须要有参数列表的不同。
- **重写（override）**：
    - 重写发生在基类和派生类之间。当一个派生类有一个与基类同名的方法，并且这个方法的参数列表相同（或者兼容（意味着派生类中的方法的参数类型应该是基类中方法参数类型的子类型）），那么派生类的方法被认为重写了基类的方法。
    - 重写是运行时多态（动态多态）的一个例子，因为调用哪个方法是在运行时根据对象的实际类型决定的。
    - 重写的方法必须有相同或者子类型的返回类型（ covariance ），这意味着派生类重写方法的返回类型可以是基类方法的返回类型的子类型。
    - 要实现重写，基类的方法通常需要被声明为虚方法（使用 `virtual` 关键字），在C++11之后，可以使用 `override` 关键字显式地表明重写的意图。

简而言之，重载关注的是同一作用域内方法名称的复用，而重写关注的是基类和派生类之间方法的实现替换。重载方法在编译时绑定，而重写方法在运行时绑定。

4. **指针和引用的区别**

| 特性 | 指针 | 引用 |
|:----|:--------|:-----|
| 定义和语法 | 指针是一个变量，其值是另一个变量的地址。声明时使用星号 `*`。例如：`int *ptr;` | 引用是变量的别名，实际上是另一个变量的另一个名称。声明时使用 ampersand `&`。例如：`int &ref = var;` |
| 内存地址 | 指针本身有内存地址，并且可以存储其他变量的地址。| 引用本身不是对象，没有自己的内存地址，它是另一个变量的别名。|
| 赋值和重新指向 | 指针可以被重新赋值，指向不同的变量。例如：`ptr = &anotherVar;` | 引用一旦初始化后，始终指向最初初始化的变量，不能更改引用的指向。 |
| 空值 | 指针可以存储空值（`nullptr` 或 `NULL`），表示不指向任何对象。 | 引用必须始终引用一个有效的对象，不能为空。 |
| 解引用 | 必须使用解引用运算符 `*` 来访问指针所指向的值。 | 可以直接使用引用来访问所引用的值，不需要解引用运算符。 |
| 指针运算 | 可以进行指针运算，如自增 `++`、自减 `--`、指针加法等，用于访问内存中的不同位置。 | 不能进行任何形式的运算。 |
| 函数参数 | 可以作为函数参数传递，用于修改实参或者传递空值。 | 可以作为函数参数传递，用于修改实参，但不能传递空值。 |
| 多维数组 | 可以用来访问多维数组，通过指针的算术运算来计算数组元素的地址。 | 不能直接用于访问多维数组，因为引用不是一个可变的地址。 |

5. **有了指针为何还要引用**

| 优点 | 说明 |
|------|------|
| 安全性 | 引用必须始终引用一个有效的对象，减少了空指针检查的需求，并且不会产生悬挂指针问题 |
| 代码简化 | 引用不需要使用解引用运算符 `*`，使得代码更加简洁和易于阅读 |
| 性能 | 传递引用可以避免对象的拷贝，节省时间和资源，并保证函数内部直接操作原始对象 |
| 函数重载 | 引用可以用来区分重载函数的参数类型，提供更直观的接口 |
| 操作符重载 | 引用在操作符重载中经常被用作参数类型，以直接操作操作数的值 |
| 常量性 | 引用可以用来指定常量引用，允许以只读方式访问对象，保证对象不会被修改 |
| API设计 | 在设计库或API时，引用可以提供更直观的接口，减少用户错误，使得API更容易理解和正确使用 |

6. **是否可以把基类对象赋值给派生类指针或引用**

可以，这是C++的向下转型，涉及到将一个基类指针或引用指向的对象转换为更具体的派生类类型。
```c++
Base *basePtr = new Derived(); // 向上转型
Derived *derivedPtr = dynamic_cast<Derived*>(basePtr); // 向下转型
```
在向下转型之前，必须确保基类指针或引用确实指向派生类对象。这可以通过 `dynamic_cast` 实现，它会在运行时检查类型安全。如果向下转型成功，derivedPtr 将指向原始的 Derived 对象；如果失败，derivedPtr 将被设置为 nullptr。

7. **虚函数表**

虚函数表（Virtual Function Table，通常缩写为 vtable）是 C++ 语言中用于实现运行时多态的一种机制。虚函数表是一个数组，其中每个元素都是一个函数指针，指向类的虚函数的地址。

每个包含虚函数的类都有自己的虚函数表，这个表在程序的只读数据段中创建。当类的对象被创建时，对象的隐藏成员 vptr（虚函数指针）会被设置为指向该类的虚函数表。这样，当通过基类指针或引用调用虚函数时，程序可以通过 vptr 找到正确的虚函数表，并调用相应地址的函数，从而实现多态。

8. **A.so调用B.so的方法，A是如何找到的**
- 编译阶段：A.so在编译时可能不知道B.so中方法的实际地址，因为它可能会在不同的地址空间中加载。因此，A.so通常会包含对B.so中方法的符号引用，而不是直接的地址。
- 运行阶段：当A.so被加载到内存中时，操作系统的动态链接器会负责解析这些符号引用。一旦符号被解析，动态链接器会将B.so中方法的实际地址写入A.so中的符号表，从而完成地址绑定。这样，当A.so中的代码调用这些方法时，它会使用B.so中的实际地址。

9. **C++栈和堆的区别，为何栈比堆块**

| 特性 | 栈 (Stack) | 堆 (Heap) |
|------|------------|-----------|
| 内存管理 | 编译器自动管理 | 程序员手动管理 |
| 性能 | 高（快速分配和释放） | 较低（较慢的分配和释放） |
| 用途 | 局部变量、函数参数 | 动态数据、对象、数组 |
| 生命周期 | 自动（与函数调用周期相同） | 手动（直到被显式释放） |
| 大小限制 | 通常有限 | 理论上只受系统内存限制 |
| 缓存友好性 | 高 | 低 |
| 访问速度 | 快 | 慢 |
| 硬件支持 | 有专门寄存器和指令优化 | 没有专门硬件优化 |
| 分配方式 | 后进先出（LIFO） | 灵活分配和释放 |
| 碎片管理 | 几乎没有碎片 | 可能需要内存碎片整理 |

10. **c++智能指针为何能不主动释放**

C++智能指针（如std::unique_ptr, std::shared_ptr和std::weak_ptr）是RAII（Resource Acquisition Is Initialization）的一个例子，它们通过在构造函数中获取资源（在本例中是指针指向的内存），并在析构函数中释放资源，来自动管理动态分配的内存。这意味着，当智能指针超出作用域时，它的析构函数会被自动调用，从而自动释放它所管理的内存。

11. **std::shared_ptr如何知道自己当前这个类被引用次数加1、减1呢**

std::shared_ptr 通过引用计数来跟踪有多少个 shared_ptr 实例共享同一个对象。引用计数的变化确实发生在构造函数、复制构造函数、赋值运算符和析构函数中，这些函数会调用特殊的原子操作函数来增加或减少引用计数，以确保在多线程环境中引用计数的更新是安全的。下面是每个情况下引用计数如何变化的详细说明：
- **构造函数**：当创建一个新的 `std::shared_ptr` 时，它会将引用计数设置为 1。
- **复制构造函数**：当使用一个已有的 `std::shared_ptr` 来构造一个新的 `shared_ptr` 时，复制构造函数会将原有 `shared_ptr` 的引用计数增加 1。
- **赋值运算符**：当给一个已有的 `std::shared_ptr` 赋值时，首先减少原有对象的引用计数，然后增加新对象的引用计数。如果赋值操作导致引用计数变为零，那么原有的对象会被销毁。
- **析构函数**：当一个 `std::shared_ptr` 被销毁时，它的析构函数会减少其所管理对象的引用计数。如果引用计数变为零，那么 `shared_ptr` 会负责销毁对象，并释放相关资源（例如，如果使用了自定义删除器，它会调用删除器）。

这些操作确保了引用计数总是正确地反映了有多少个 `std::shared_ptr` 实例指向同一个对象，从而实现了自动的内存管理。

12. **如果在一个函数参数中以值的形式传入std::shared_ptr，那么它的引用计数是如何变化的**

当以值的形式传入 std::shared_ptr 作为函数参数时，实际上是将 shared_ptr 复制到函数的形参中。这会涉及到 shared_ptr 的复制构造函数，引用计数会相应地增加。当函数返回时，函数内的 shared_ptr 形参会被销毁。形参的析构函数会将引用计数减少 1。因此，传入函数的 shared_ptr 的引用计数在函数调用期间会增加，然后在函数返回时减少。这个过程是自动的，由 shared_ptr 的内部机制管理。

13. **利用锁的形式解决多线程问题有什么问题，不用锁可以实现线程安全吗**

使用锁来解决多线程问题是常见的做法，因为锁可以提供互斥访问，确保在同一时刻只有一个线程可以访问共享资源。然而，使用锁也存在一些问题和挑战：
1. **死锁**：当两个或多个线程互相等待对方持有的锁时，可能会导致死锁，从而使程序挂起。
2. **竞态条件**：即使使用了锁，如果锁的使用不当，仍然可能发生竞态条件，尤其是在锁的保护范围不正确或者锁的保护不够严格时。
3. **性能开销**：锁的操作通常会有性能开销，因为它们需要操作系统进行上下文切换和调度。
4. **复杂性**：使用锁会增加代码的复杂性，使得代码更难理解和维护。
5. **锁粒度**：锁的粒度需要仔细考虑。过粗的锁可能会导致性能瓶颈，而过细的锁则可能导致复杂性和死锁问题。

尽管使用锁存在这些问题，但在许多情况下，锁是实现线程安全的必要手段。不过，确实存在一些无锁编程技术，可以避免使用锁而实现线程安全，例如：
1. **原子操作**：许多现代处理器提供了原子操作指令，这些指令可以保证对某个内存位置的读写操作是原子的，不可中断的。例如，C++11引入了原子操作库，如 `std::atomic`，可以用来实现无锁的数据结构。
2. **内存模型**：C++11引入了强内存模型，它提供了一系列的内存顺序保证，允许开发者通过指定内存访问的顺序来避免数据竞争，从而实现无锁编程。
3. **锁自由数据结构**：一些数据结构如锁自由队列、锁自由堆等，它们的设计避免了使用锁，而是依赖于原子操作和内存屏障来保证线程安全。
4. **软件事务内存（STM）**：STM是一种编程模型，它允许代码块在事务中执行，如果事务成功，则所有的修改会一次性提交，如果事务失败，则所有的修改会回滚，从而避免了锁的使用。

14. **std::sharedptr是线程安全吗**

`std::shared_ptr` 的引用计数机制是线程安全的，但是它的接口并不保证线程安全。这意味着，如果你在多线程环境中使用 `std::shared_ptr`，你需要自己确保线程安全。

例如，如果多个线程同时尝试创建或销毁 `std::shared_ptr`，或者多个线程同时访问 `std::shared_ptr` 所管理的资源，可能会导致竞态条件和其他同步问题。
为了解决这个问题，你可以采取以下措施：
1. 使用 `std::mutex` 来保护对 `std::shared_ptr` 的访问，确保在多线程环境下只有单个线程可以修改引用计数。
2. 避免在多个线程之间共享 `std::shared_ptr`，或者确保所有的 `std::shared_ptr` 操作都由单个线程执行。


4. **异常处理（Exception Handling）**：C++提供了一套异常处理机制，包括`try`、`catch`和`throw`关键字，用于处理程序运行时的错误情况。

5. **标准模板库（Standard Template Library, STL）**：STL是C++的一个重要组成部分，提供了一系列的模板类和函数，包括容器（如vector、map等）、迭代器、算法和函数对象。

6. **引用（References）**：C++中的引用是别名的同义词，它为变量提供了间接访问的能力，常用于函数参数传递，以避免拷贝开销。

7. **内联函数（Inline Functions）**：内联函数可以减少函数调用的开销，提高程序的执行效率。

8. **运算符重载（Operator Overloading）**：C++允许程序员为自定义类型重载各种运算符，使得这些类型可以使用类似于内置类型的方式进行操作。

9. **多重继承（Multiple Inheritance）**：C++支持多重继承，即一个类可以从多个父类继承属性和方法。

10. **构造函数和析构函数（Constructors and Destructors）**：构造函数用于初始化对象，析构函数用于在对象生命周期结束时执行清理工作。

11. **虚函数和纯虚函数（Virtual Functions and Pure Virtual Functions）**：虚函数用于实现多态，而纯虚函数则用于接口的定义。

12. **新的数据类型和转换机制**：C++引入了一些新的数据类型，如`bool`、`enum class`等，并提供了更丰富的类型转换机制。

13. **更严格的类型检查**：C++提供了更严格的类型检查，有助于发现潜在的错误。

14. **支持Unicode和其他国际化特性**：C++支持Unicode字符集，有助于创建国际化的应用程序。

这些特性使得C++成为了一个功能强大的编程语言，适用于各种不同的应用场景，包括系统编程、游戏开发、桌面应用、网络编程等。同时，C++也在不断地发展和完善中，每个新的标准版本都会引入新的特性和改进。
