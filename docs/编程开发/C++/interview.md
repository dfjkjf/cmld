---
sort: 1
---

# 面试

1. **C++结构体和类的区别**

类和结构体的区别：增加了权限、构造/析构函数、成员函数

2. **多态的意义**

是的，在C++中，多态性可以分为两种主要形式：静态多态和动态多态。
- 静态多态（编译时多态）：
   - 静态多态是在编译时确定函数调用的多态形式。
   - 它主要通过**函数重载**和**模板**来实现。
   - 函数重载允许在同一作用域内声明多个同名函数，但它们的参数列表必须不同。编译器根据提供的参数类型和数量来确定调用哪个函数。
   - 模板允许编写与类型无关的代码，编译器会为使用模板的每个具体类型生成不同的函数版本。
- 动态多态（运行时多态）：
   - 动态多态是在程序运行时确定函数调用的多态形式。
   - 它主要通过**虚函数**和**继承**来实现。
   - 虚函数是在基类中使用关键字 `virtual` 声明的函数，它们可以在派生类中被**重写**。
   - 当通过基类的指针或引用调用虚函数时，实际调用的函数版本取决于指针或引用所指向的对象的实际类型（即派生类类型）。
   - 这种在运行时根据对象的实际类型来决定调用哪个函数版本的过程称为动态绑定或晚期绑定。
   
3. **重载**和**重写**的区别

- **重载（overload）**：
    - 重载发生在同一个类内部，或者在同一作用域内，当有两个或多个方法具有相同的名字，但是参数列表不同（参数的数量、类型或者参数的顺序不同）时，这些方法被认为是重载的。
    - 重载是编译时多态（静态多态）的一个例子，因为调用哪个方法是在编译时根据方法签名决定的。
    - 重载的方法可以有不同的返回类型，但是返回类型本身不足以区分重载的方法，必须要有参数列表的不同。
- **重写（overrid）**：
    - 重写发生在基类和派生类之间。当一个派生类有一个与基类同名的方法，并且这个方法的参数列表相同（或者兼容（意味着派生类中的方法的参数类型应该是基类中方法参数类型的子类型）），那么派生类的方法被认为重写了基类的方法。
    - 重写是运行时多态（动态多态）的一个例子，因为调用哪个方法是在运行时根据对象的实际类型决定的。
    - 重写的方法必须有相同或者子类型的返回类型（ covariance ），这意味着派生类重写方法的返回类型可以是基类方法的返回类型的子类型。
    - 要实现重写，基类的方法通常需要被声明为虚方法（使用 `virtual` 关键字），在C++11之后，可以使用 `override` 关键字显式地表明重写的意图。

简而言之，重载关注的是同一作用域内方法名称的复用，而重写关注的是基类和派生类之间方法的实现替换。重载方法在编译时绑定，而重写方法在运行时绑定。

4. **指针和引用的区别**

| 特性 | 指针 | 引用 |
|:----|:--------|:-----|
| 定义和语法 | 指针是一个变量，其值是另一个变量的地址。声明时使用星号 `*`。例如：`int *ptr;` | 引用是变量的别名，实际上是另一个变量的另一个名称。声明时使用 ampersand `&`。例如：`int &ref = var;` |
| 内存地址 | 指针本身有内存地址，并且可以存储其他变量的地址。| 引用本身不是对象，没有自己的内存地址，它是另一个变量的别名。|
| 赋值和重新指向 | 指针可以被重新赋值，指向不同的变量。例如：`ptr = &anotherVar;` | 引用一旦初始化后，始终指向最初初始化的变量，不能更改引用的指向。 |
| 空值 | 指针可以存储空值（`nullptr` 或 `NULL`），表示不指向任何对象。 | 引用必须始终引用一个有效的对象，不能为空。 |
| 解引用 | 必须使用解引用运算符 `*` 来访问指针所指向的值。 | 可以直接使用引用来访问所引用的值，不需要解引用运算符。 |
| 指针运算 | 可以进行指针运算，如自增 `++`、自减 `--`、指针加法等，用于访问内存中的不同位置。 | 不能进行任何形式的运算。 |
| 函数参数 | 可以作为函数参数传递，用于修改实参或者传递空值。 | 可以作为函数参数传递，用于修改实参，但不能传递空值。 |
| 多维数组 | 可以用来访问多维数组，通过指针的算术运算来计算数组元素的地址。 | 不能直接用于访问多维数组，因为引用不是一个可变的地址。 |

5. **有了指针为何还要引用**

| 优点 | 说明 |
|------|------|
| 安全性 | 引用必须始终引用一个有效的对象，减少了空指针检查的需求，并且不会产生悬挂指针问题 |
| 代码简化 | 引用不需要使用解引用运算符 `*`，使得代码更加简洁和易于阅读 |
| 性能 | 传递引用可以避免对象的拷贝，节省时间和资源，并保证函数内部直接操作原始对象 |
| 函数重载 | 引用可以用来区分重载函数的参数类型，提供更直观的接口 |
| 操作符重载 | 引用在操作符重载中经常被用作参数类型，以直接操作操作数的值 |
| 常量性 | 引用可以用来指定常量引用，允许以只读方式访问对象，保证对象不会被修改 |
| API设计 | 在设计库或API时，引用可以提供更直观的接口，减少用户错误，使得API更容易理解和正确使用 |

6. **是否可以把基类对象赋值给派生类指针或引用**

可以，这是C++的向下转型，涉及到将一个基类指针或引用指向的对象转换为更具体的派生类类型。
```c++
Base *basePtr = new Derived(); // 向上转型
Derived *derivedPtr = dynamic_cast<Derived*>(basePtr); // 向下转型
```
在向下转型之前，必须确保基类指针或引用确实指向派生类对象。这可以通过 `dynamic_cast` 实现，它会在运行时检查类型安全。如果向下转型成功，derivedPtr 将指向原始的 Derived 对象；如果失败，derivedPtr 将被设置为 nullptr。


4. **异常处理（Exception Handling）**：C++提供了一套异常处理机制，包括`try`、`catch`和`throw`关键字，用于处理程序运行时的错误情况。

5. **标准模板库（Standard Template Library, STL）**：STL是C++的一个重要组成部分，提供了一系列的模板类和函数，包括容器（如vector、map等）、迭代器、算法和函数对象。

6. **引用（References）**：C++中的引用是别名的同义词，它为变量提供了间接访问的能力，常用于函数参数传递，以避免拷贝开销。

7. **内联函数（Inline Functions）**：内联函数可以减少函数调用的开销，提高程序的执行效率。

8. **运算符重载（Operator Overloading）**：C++允许程序员为自定义类型重载各种运算符，使得这些类型可以使用类似于内置类型的方式进行操作。

9. **多重继承（Multiple Inheritance）**：C++支持多重继承，即一个类可以从多个父类继承属性和方法。

10. **构造函数和析构函数（Constructors and Destructors）**：构造函数用于初始化对象，析构函数用于在对象生命周期结束时执行清理工作。

11. **虚函数和纯虚函数（Virtual Functions and Pure Virtual Functions）**：虚函数用于实现多态，而纯虚函数则用于接口的定义。

12. **新的数据类型和转换机制**：C++引入了一些新的数据类型，如`bool`、`enum class`等，并提供了更丰富的类型转换机制。

13. **更严格的类型检查**：C++提供了更严格的类型检查，有助于发现潜在的错误。

14. **支持Unicode和其他国际化特性**：C++支持Unicode字符集，有助于创建国际化的应用程序。

这些特性使得C++成为了一个功能强大的编程语言，适用于各种不同的应用场景，包括系统编程、游戏开发、桌面应用、网络编程等。同时，C++也在不断地发展和完善中，每个新的标准版本都会引入新的特性和改进。
