---
sort: 7
---

# C++新特性

## 问题

### C++11

1. **自动类型推导**
   - 请解释`auto`和`decltype`关键字的作用。
   - `auto`和`decltype`有什么区别？
2. **基于范围的for循环**
   - 如何使用基于范围的for循环？它有什么优点？
3. **智能指针**
   - 请介绍C++11中的智能指针（`std::unique_ptr`, `std::shared_ptr`, `std::weak_ptr`）。
   - `std::unique_ptr`和`std::shared_ptr`有什么区别？
4. **Lambda表达式**
   - 什么是Lambda表达式？请给出一个例子。
   - Lambda表达式如何捕获外部变量？
5. **线程支持**
   - C++11是如何支持多线程的？
   - `std::thread`和`std::async`有什么区别？
6. **锁和互斥量**
   - 请解释`std::mutex`和`std::lock_guard`的作用。
   - `std::lock_guard`和`std::unique_lock`有什么区别？
7. **初始化列表**
   - 初始化列表是什么？请给出一个例子。
   - 初始化列表和构造函数初始化有什么区别？
8. **构造函数委派**
   - 请解释C++11中的构造函数委派。
9. **默认和删除函数**
   - 如何在C++11中指定默认构造函数？
   - 如何在C++11中禁止某个函数？
10. **模板增强**
    - 请解释C++11中的尾置返回类型。
    - `std::function`和`std::bind`有什么作用？
11. **强类型枚举**
    - 请解释C++11中的强类型枚举（`enum class`）。
12. **原子操作**
    - 请解释C++11中的原子操作和`std::atomic`。
13. **特性检测**
    - 如何使用C++11的`<type_traits>`来进行编译时特性检测？
14. **变长模板参数**
    - 请解释C++11中的变长模板参数。
15. **long long 类型**
    - C++11中`long long`类型支持的范围是多少？

### C++14

1. **泛型Lambda表达式**
   - C++14中的Lambda表达式支持泛型。请解释泛型Lambda表达式，并给出一个例子。
2. **变量模板**
   - 请解释C++14中的变量模板是什么，并给出一个使用示例。
3. **聚合体初始化改进**
   - C++14对聚合体（aggregate）的初始化进行了改进，请说明这些改进。
4. **Lambda表达式捕获`this`指针**
   - 在C++14中，Lambda表达式可以捕获`*this`，请解释这意味着什么。
5. **别名模板（Alias Template）的扩展**
   - C++14中别名模板有哪些新的使用方式？
6. **函数返回类型推导**
   - C++14允许在函数返回类型中使用`auto`，请解释这是如何工作的。
7. **改进的constexpr**
   - C++14中`constexpr`函数有哪些新的特性？
8. **二元运算符`->`的增强**
   - 请解释C++14中链式成员访问操作符`->`的增强。
9. **继承构造函数**
   - C++14中如何使用继承构造函数？
10. **数字分隔符**
    - C++14引入了数字分隔符，请给出一个例子并解释其作用。
11. **增强的线程支持**
    - C++14在`<thread>`库中增加了哪些新特性？
12. **退化副本消除（Copy Elision）**
    - 请解释C++14中退化副本消除的概念及其对性能的影响。
13. **异构查找算法**
    - C++14中引入了哪些新的异构查找算法？
14. **扩展的`std::tuple`功能**
    - C++14中`std::tuple`有哪些新的功能？
15. **`std::make_unique`**
    - C++14中`std::make_unique`的作用是什么？

### C++17

1. **结构化绑定**
   - 请解释C++17中的结构化绑定，并给出一个例子。
2. **折叠表达式**
   - 请解释C++17中的折叠表达式，并给出一个使用示例。
3. **`if constexpr`**
   - 请解释C++17中的`if constexpr`语句的作用和用法。
4. **内联变量**
   - 请解释C++17中内联变量的概念及其用途。
5. **模板参数推导改进**
   - C++17中对于模板参数推导有哪些改进？
6. **构造函数模板参数推导**
   - 请解释C++17中如何对构造函数的模板参数进行推导。
7. **继承构造函数的改进**
   - C++17中对于继承构造函数有哪些改进？
8. **`std::optional`**
   - 请解释C++17中`std::optional`的作用和使用场景。
9. **`std::variant`**
   - 请解释C++17中`std::variant`的作用和使用场景。
10. **`std::any`**
    - 请解释C++17中`std::any`的作用和使用场景。
11. **并行算法**
    - C++17中引入了哪些并行算法？
12. **文件系统库**
    - 请解释C++17中文件系统库的作用和基本用法。
13. **新关键字`constexpr`**
    - C++17中`constexpr`关键字有哪些新的使用方式？
14. **一致性初始化改进**
    - C++17中对一致性初始化有哪些改进？
15. **`std::byte`**
    - 请解释C++17中`std::byte`的作用和使用场景。

## 答案

### C++11
1. **自动类型推导**
   - `auto`用于自动推导变量的类型，而`decltype`用于推导表达式的类型。
   - `auto`在声明变量时使用，`decltype`在需要表达式类型时使用，如模板编程中。
2. **基于范围的for循环**
   - 基于范围的for循环用于遍历容器或数组，形式为`for (_DECLARATION_ : _EXPR_)`。
   - 它简化了遍历容器的过程，不需要使用迭代器。
3. **智能指针**
   - `std::unique_ptr`是独占所有权的智能指针，`std::shared_ptr`是共享所有权的智能指针，`std::weak_ptr`用于解决`std::shared_ptr`可能引起的循环引用问题。
   - `std::unique_ptr`禁止复制，`std::shared_ptr`允许复制，多个`std::shared_ptr`可以共享同一资源。
4. **Lambda表达式**
   - Lambda表达式是一个匿名函数对象，可以捕获一定范围内的变量。
   - `[=] (int x) { return x * x; }`是一个Lambda表达式，它捕获了外部作用域中的所有变量，并定义了一个参数`x`。
5. **线程支持**
   - C++11通过`<thread>`, `<mutex>`, `<async>`等头文件提供了线程支持。
   - `std::thread`用于创建和操作线程，`std::async`用于异步执行函数。
6. **锁和互斥量**
   - `std::mutex`是互斥量类，用于同步线程，防止同时访问同一数据。
   - `std::lock_guard`是一个作用域锁，它在构造时自动加锁，在析构时自动解锁。`std::unique_lock`提供了更多的灵活性，可以手动加锁和解锁。
7. **初始化列表**
   - 初始化列表是一种初始化对象的方式，如`std::vector<int> v = {1, 2, 3};`。
   - 初始化列表可以用于构造函数，以初始化成员变量。
8. **构造函数委派**
   - 构造函数委派允许一个构造函数调用另一个构造函数，以避免代码重复。
9. **默认和删除函数**
   - 默认函数可以通过`= default`指定，而删除函数可以通过`= delete`禁止。
   - 例如，`void func(int) = delete;`将禁止使用整型参数调用`func`。
10. **模板增强**
    - 尾置返回类型允许在模板函数中先声明参数，再声明返回类型。
    - `std::function`是一个通用的多态函数包装器，`std::bind`用于将函数和参数绑定到一起。
11. **强类型枚举**
    - 强类型枚举通过`enum class`定义，可以防止枚举类型的名字冲突。
12. **原子操作**
    - 原子操作确保在多线程环境中对某个值的操作是原子的。
    - `std::atomic`是一个模板类，提供了原子操作的基本类型。
13. **特性检测**
    - 通过`<type_traits>`中的类型特征，可以在编译时检测类型是否具有某些特性。
14. **变长模板参数**
    - 变长模板参数允许模板接受可变数量的参数，如`template <typename... Args> void func(Args... args);`。
15. **long long 类型**
    - `long long`是一个64位整数类型，至少提供-2^63到2^63-1的范围。

### C++14

1. **泛型Lambda表达式**
   - 泛型Lambda表达式允许在Lambda表达式中使用自动类型推导，而不需要指定具体类型。
   - 例子：`auto lambda = [](auto x, auto y) { return x + y; };`
2. **变量模板**
   - 变量模板允许为类型参数化变量定义模板。
   - 示例：`template<typename T> T pi = T(3.141592653589793238462643383);`
3. **聚合体初始化改进**
   - C++14放宽了聚合体初始化的条件，允许聚合体有非静态成员、基类和默认构造函数。
4. **Lambda表达式捕获`this`指针**
   - Lambda表达式可以通过`*this`捕获当前对象的拷贝，而不仅仅是引用。
   - 这允许Lambda在对象超出作用域后仍然可以使用其拷贝。
5. **别名模板（Alias Template）的扩展**
   - C++14中别名模板可以模板化，即可以拥有自己的模板参数。
6. **函数返回类型推导**
   - 函数可以在声明时使用`auto`来推导返回类型，而无需在函数体中明确指定。
   - 示例：`auto add(int a, int b) { return a + b; }`
7. **改进的constexpr**
   - C++14中`constexpr`函数可以具有非常量表达式，并且可以返回非常量表达式的结果。
8. **二元运算符`->`的增强**
   - C++14中，`->`运算符可以用于连续调用成员函数，即所谓的“箭头链”（arrow chaining）。
9. **继承构造函数**
   - C++14允许派生类继承基类的构造函数，简化了派生类的构造函数编写。
10. **数字分隔符**
    - C++14引入了数字分隔符`'`，用于提高大数字的可读性。
    - 示例：`int number = 1'000'000;`表示一百万。
11. **增强的线程支持**
    - C++14在`<thread>`库中增加了`std::thread::hardware_concurrency()`，用于查询硬件并发线程数。
12. **退化副本消除（Copy Elision）**
    - C++14中编译器可以优化掉不必要的副本，以提高性能。
13. **异构查找算法**
    - C++14中引入了`std::equal`和`std::mismatch`的异构版本，允许比较不同类型的序列。
14. **扩展的`std::tuple`功能**
    - C++14中`std::tuple`增加了`std::get<>()`的变体，允许获取成员的引用。
15. **`std::make_unique`**
    - `std::make_unique`是一个模板函数，用于创建一个`std::unique_ptr`对象，简化了智能指针的创建。

### C++17

1. **结构化绑定**
   - 结构化绑定允许你从数组或元组类型的表达式中绑定多个变量。
   - 例子：`auto [x, y, z] = tuple<int, string, double>(1, "example", 3.14);`
2. **折叠表达式**
   - 折叠表达式用于简化变参模板中的累积操作。
   - 示例：`template<typename... Args> auto sum(Args... args) { return (... + args); }`
3. **`if constexpr`**
   - `if constexpr`是编译时分支，它在编译时根据常量表达式的值来选择分支。
   - 用法：`if constexpr (std::is_same_v<T, int>) { /* code for int */ } else { /* code for other types */ }`
4. **内联变量**
   - 内联变量允许在类定义内声明静态成员变量，并在头文件中定义它们，以避免链接问题。
   - 用途：用于定义常量数据成员，如`inline constexpr int max_size = 100;`
5. **模板参数推导改进**
   - C++17中，模板参数推导现在可以用于构造函数的自动推导。
6. **构造函数模板参数推导**
   - C++17允许在构造函数模板中使用自动模板参数推导。
7. **继承构造函数的改进**
   - C++17中，继承构造函数现在可以与模板一起使用，提供了更多的灵活性。
8. **`std::optional`**
   - `std::optional`用于表示可能存在或可能不存在的值。
   - 使用场景：当函数可能返回有效值或无值时，可以用`std::optional`代替返回指针或空值。
9. **`std::variant`**
   - `std::variant`是一个类型安全的联合体，可以存储几种不同类型的值。
   - 使用场景：当需要处理多种可能的数据类型时，可以使用`std::variant`。
10. **`std::any`**
    - `std::any`可以存储任何类型的值。
    - 使用场景：当需要存储类型在运行时才能确定的值时，可以使用`std::any`。
11. **并行算法**
    - C++17引入了并行版本的算法，如`std::sort`和`std::find`，可以通过`std::execution::par`来并行执行。
12. **文件系统库**
    - 文件系统库提供了跨平台的文件系统操作功能。
    - 基本用法：包括路径操作、文件状态查询、目录遍历等。
13. **新关键字`constexpr`**
    - C++17中`constexpr`函数可以具有非常量表达式，并且可以返回非常量表达式的结果。
14. **一致性初始化改进**
    - C++17中一致性初始化得到了改进，可以直接在构造函数中使用初始化列表。
15. **`std::byte`**
    - `std::byte`是用于表示单个字节的新类型，它提供了对字节操作的类型安全支持。
    - 使用场景：当需要处理字节级别的数据时，可以使用`std::byte`。

## STL

### 容器
1. **`std::array`** - 固定大小的数组，与普通数组相比，提供了更好的接口和类型安全。
2. **`std::forward_list`** - 单链表，提供了常数时间内的插入和删除操作，比`std::list`更轻量级。
3. **`std::unordered_map`** - 哈希表实现的关联容器，提供了平均常数时间内的查找、插入和删除操作。
4. **`std::unordered_multimap`** - 允许键值重复的`std::unordered_map`。
5. **`std::unordered_set`** - 哈希表实现的集合，提供了平均常数时间内的查找、插入和删除操作。
6. **`std::unordered_multiset`** - 允许元素重复的`std::unordered_set`。
### 算法
1. **`std::all_of`**, **`std::any_of`**, **`std::none_of`** - 用于检查范围中的元素是否满足特定条件。
2. **`std::find_if_not`** - 反向的`std::find_if`，查找第一个不满足条件的元素。
3. **`std::copy_if`** - 只复制满足特定条件的元素。
4. **`std::move`** - 移动元素而不是复制它们，用于优化性能。
5. **`std::move_if_noexcept`** - 如果移动构造函数不抛出异常，则移动元素。
6. **`std::iota`** - 用于填充范围内的元素序列，通常与`std::generate`或`std::copy`结合使用。
### 函数对象
1. **`std::function`** - 表示可调用对象的封装，可以持有函数、Lambda表达式、函数对象等。
2. **`std::bind`** - 用于绑定函数参数，创建新的可调用对象。
3. **`std::placeholder`** - 与`std::bind`一起使用，用于表示绑定位置。
### 元组
1. **`std::tuple`** - 可以包含任意数量和类型元素的集合，用于创建小型、固定大小的聚合数据结构。
2. **`std::get`** - 用于访问元组中的元素。
3. **`std::tie`** - 用于解包元组或创建从元组中部分元素组成的新的元组。
### 其他
1. **`std::chrono`** - 提供了时间和日期的库，包括持续时间、时钟和定时器。
2. **`std::ratio`** - 用于表示最简分数的模板类，与`std::chrono`一起使用。
3. **`std::atomic`** - 提供了原子操作，用于编写无锁编程和多线程应用程序。
3. **`std::condition_variable `** - 用于线程同步，允许线程在某些条件不满足时挂起（等待），直到条件成立。
4. **`std::thread`** - 表示线程的类，用于创建和管理线程。
5. **`std::async`** - 用于异步执行函数。
5. **`std::mutex`** - 提供互斥锁，用于同步线程。
6. **`std::lock_guard`** 和 **`std::unique_lock`** - 用于管理互斥锁的RAII封装。