---
sort: 7
---

# C++新特性

## 关键字

| 关键字        | 含义                           | 作用                                                         | 优缺点                                                         | 适用场景                                         | 与已有对比                  |
|---------------|--------------------------------|--------------------------------------------------------------|----------------------------------------------------------------|--------------------------------------------------|----------------------------|
| alignas       | 内存对齐声明                   | 指定变量或类型的内存对齐要求                                 | 优点：提高内存访问效率；缺点：使用较为复杂，容易出错           | 需要特定内存对齐的场景，如硬件交互、性能优化等       | 代替了offsetof和pragma指令 |
| alignof       | 内存对齐查询                   | 返回类型或对象所需的对齐                                     | 优点：简化对齐要求的查询；缺点：较少直接使用                   | 检查或计算对象的对齐要求时                        | 新特性                      |
| auto          | 类型推导                        | 让编译器自动确定变量的类型                                   | 优点：简化代码，提高可读性；缺点：可能降低代码清晰度           | 任何可以自动推导类型的场景，如循环、初始化等       | 代替了冗长的类型声明         |
| constexpr     | 编译时常量表达式               | 指定变量或函数在编译时求值                                   | 优点：提高性能，允许在编译时进行更多的优化；缺点：使用有限制   | 需要在编译时求值的场景，如数组大小、配置参数等     | 加强了const的作用           |
| decltype      | 类型推导                        | 返回操作数的类型                                             | 优点：灵活的类型推导；缺点：可能增加代码理解难度               | 需要根据表达式类型进行类型推导的场景                | 新特性                      |
| noexcept      | 异常说明                       | 指定函数不会抛出异常                                         | 优点：提供更好的错误处理和性能优化；缺点：需要正确使用         | 确定函数不会抛出异常的场景，如性能敏感的代码       | 加强了throw()的作用         |
| nullptr       | 空指针字面量                   | 表示空指针                                                   | 优点：类型安全，清晰；缺点：需要修改旧代码以兼容               | 代替NULL，用于指针和对象比较                      | 新特性                      |
| static_assert | 静态断言                       | 在编译时检查条件是否为真                                     | 优点：提前发现错误，防止错误的编译；缺点：使用时需要小心       | 需要在编译时检查条件的场景，如模板参数检查等       | 代替了运行时断言            |
| thread_local  | 线程局部存储                   | 指示变量具有线程存储期                                       | 优点：简化线程局部变量的管理；缺点：可能导致资源浪费           | 需要每个线程有独立变量的场景，如线程局部存储等     | 代替了TLS平台特定的实现     |
| override      | 覆盖声明                       | 表明一个虚函数意在覆盖基类的虚函数                           | 优点：增加明确性，防止无意中的函数隐藏；缺点：需要修改旧代码 | 用于显式声明覆盖基类虚函数的场景                  | 新特性                      |
| final         | 终止继承                       | 表明类不能被继承，或者虚函数不能被覆盖                       | 优点：提供了一种防止继承的方法；缺点：降低了代码的灵活性       | 当需要阻止继承或者覆盖时                           | 新特性                      |

## 语法

| 语法特性          | 含义                                                         | 作用                                                         | 优缺点                                                         | 适用场景                                         | 与已有对比                  |
|-------------------|--------------------------------------------------------------|--------------------------------------------------------------|----------------------------------------------------------------|--------------------------------------------------|----------------------------|
| 基于范围的for循环 | 用于遍历容器中的元素                                       | 简化遍历容器和数组的过程                                     | 优点：代码更简洁，可读性更高；缺点：不适用于非容器类型         | 遍历数组、容器和其他迭代器支持的序列              | 代替了传统的for循环         |
| 初始化列表        | 用于对象的初始化                                           | 提供了一种简洁的初始化对象的方式                             | 优点：代码更清晰，支持非默认构造函数；缺点：语法稍微复杂       | 初始化对象、容器和数组等                         | 代替了构造函数和赋值操作   |
| Lambda表达式      | 允许定义匿名函数                                           | 提供了一种简便的方法来定义和传递短小的函数                   | 优点：代码更简洁，提高了灵活性；缺点：可能导致代码可读性下降   | 简单的回调函数、算法中的临时操作等                | 代替了std::bind和函数对象 |
| 变长模板参数      | 允许模板接受可变数量的参数                                 | 提供了编写能够处理不同数量参数的模板的能力                   | 优点：增强了模板的通用性；缺点：可能导致模板代码更复杂         | 容器、元编程、泛型编程等                         | 新特性                      |
| 委托构造函数      | 允许构造函数调用另一个构造函数                             | 简化了构造函数之间的代码共享                                 | 优点：减少了代码重复，提高了可维护性；缺点：可能增加理解的复杂性 | 当多个构造函数有共同代码时                         | 新特性                      |
| 继承构造函数      | 允许派生类自动继承基类的构造函数                           | 简化了派生类构造函数的编写                                   | 优点：减少了代码重复，提高了可维护性；缺点：可能限制构造函数的灵活性 | 派生类需要使用基类构造函数的场景                  | 新特性                      |
| 默认和删除函数    | 允许显式声明默认构造函数和析构函数，以及删除其他默认生成的函数 | 提供了对默认函数生成的更细粒度控制                           | 优点：增强了类型的安全性；缺点：可能需要更多的语法             | 控制对象的默认行为，如禁止拷贝、移动等            | 新特性                      |
| 强类型枚举        | 提供了类型安全的枚举类型                                   | 防止了枚举类型的无意转换和比较                               | 优点：增强了类型安全，减少了错误；缺点：语法稍微复杂           | 需要类型安全的枚举场景                            | 代替了传统的枚举类型         |
| 智能指针          | 提供了自动管理内存的指针类型                               | 简化了资源管理，减少了内存泄漏的风险                         | 优点：自动管理内存，减少错误；缺点：需要理解智能指针的语义     | 管理动态分配的内存、自动释放资源等                | 代替了传统的指针和new/delete |

## STL

### 容器
1. **`std::array`** - 固定大小的数组，与普通数组相比，提供了更好的接口和类型安全。
2. **`std::forward_list`** - 单链表，提供了常数时间内的插入和删除操作，比`std::list`更轻量级。
3. **`std::unordered_map`** - 哈希表实现的关联容器，提供了平均常数时间内的查找、插入和删除操作。
4. **`std::unordered_multimap`** - 允许键值重复的`std::unordered_map`。
5. **`std::unordered_set`** - 哈希表实现的集合，提供了平均常数时间内的查找、插入和删除操作。
6. **`std::unordered_multiset`** - 允许元素重复的`std::unordered_set`。
### 算法
1. **`std::all_of`**, **`std::any_of`**, **`std::none_of`** - 用于检查范围中的元素是否满足特定条件。
2. **`std::find_if_not`** - 反向的`std::find_if`，查找第一个不满足条件的元素。
3. **`std::copy_if`** - 只复制满足特定条件的元素。
4. **`std::move`** - 移动元素而不是复制它们，用于优化性能。
5. **`std::move_if_noexcept`** - 如果移动构造函数不抛出异常，则移动元素。
6. **`std::iota`** - 用于填充范围内的元素序列，通常与`std::generate`或`std::copy`结合使用。
### 函数对象
1. **`std::function`** - 表示可调用对象的封装，可以持有函数、Lambda表达式、函数对象等。
2. **`std::bind`** - 用于绑定函数参数，创建新的可调用对象。
3. **`std::placeholder`** - 与`std::bind`一起使用，用于表示绑定位置。
### 智能指针
1. **`std::unique_ptr`** - 独占所有权的智能指针，用于替代`std::auto_ptr`。
2. **`std::shared_ptr`** - 共享所有权的智能指针，允许多个指针共享同一对象。
3. **`std::weak_ptr`** - 弱引用的智能指针，用于解决`std::shared_ptr`循环引用的问题。
### 元组
1. **`std::tuple`** - 可以包含任意数量和类型元素的集合，用于创建小型、固定大小的聚合数据结构。
2. **`std::get`** - 用于访问元组中的元素。
3. **`std::tie`** - 用于解包元组或创建从元组中部分元素组成的新的元组。
### 其他
1. **`std::chrono`** - 提供了时间和日期的库，包括持续时间、时钟和定时器。
2. **`std::ratio`** - 用于表示最简分数的模板类，与`std::chrono`一起使用。
3. **`std::atomic`** - 提供了原子操作，用于编写无锁编程和多线程应用程序。
3. **`std::condition_variable `** - 用于线程同步，允许线程在某些条件不满足时挂起（等待），直到条件成立。
4. **`std::thread`** - 表示线程的类，用于创建和管理线程。
5. **`std::mutex`** - 提供互斥锁，用于同步线程。
6. **`std::lock_guard`** 和 **`std::unique_lock`** - 用于管理互斥锁的RAII封装。



## 类型转换

`static_cast` ：这是 C++ 中最常用的类型转换方法。它在编译时执行，当您在数据类型之间进行显式转换时应该使用它;
`dynamic_cast` ：此方法专门用于在类层次结构中的基类和派生类之间安全地转换指针和引用;
`reinterpret_cast` ：此转换更改指针、引用或整数值的类型。它也称为按位转换，因为它改变了编译器解释底层位的方式。仅当您对自己正在做的事情有深入了解时才使用 reinterpret_cast ，因为它不能保证结果值有意义;
`const_cast` ：此转换方法用于从变量中删除 const 限定符。通常不建议这样做，但在某些无法控制变量常量的情况下可能很有用。
```c++
int a = 10;
float b = static_cast<float>(a); // static_cast from int to float

class Base {};
class Derived : public Base {};
Base* base_ptr = new Derived();
Derived* derived_ptr = dynamic_cast<Derived*>(base_ptr); // dynamic_cast from Base* to Derived*

int* a = new int(42);
long b = reinterpret_cast<long>(a); // reinterpret_cast from int* to long

const int a = 10;
int* ptr = const_cast<int*>(&a);  // const_cast from const int* to int*
*ptr = 20;
```

## Lambda 函数

匿名函数，可以更轻松地创建函数对象。

```c++
auto add = [](int a, int b) -> int { return a + b; };
int sum = add(42, 13); // sum is equal to 55
```

c++14 通用 lambda 函数：允许使用 "auto "类型占位符声明 lambda 函数参数。
```c++
auto add = [](auto a, auto b) { return a + b; };
auto sum_i = add(42, 13); // Still works with integers
auto sum_f = add(3.14, 2.72); // Now works with doubles too
```

## 

允许您使用模板参数定义变量。
```c++
template <typename T>
constexpr T pi = T(3.1415926535897932385);
float r = pi<float>; // Instantiated as a float
double d = pi<double>; // Instantiated as a double
```

## 时间

使用 chrono 库来处理日期和时间，该库是标准库 (STL) 的一部分。 chrono 库提供了各种数据类型和函数来表示和操作持续时间、时间点和时钟。

1. `duration` 表示时间跨度，可以用秒、分钟、小时等各种单位表示。要创建持续时间，请使用 std::chrono::duration 模板类。常见的预定义持续时间类型有：
- std::chrono::nanoseconds
- std::chrono::milliseconds
- std::chrono::microseconds
- std::chrono::seconds
- std::chrono::minutes
- std::chrono::hours

2. `time_point` 代表特定时间点。它通常是使用持续时间和时钟的组合来创建的。在 C++ 中， chrono 库提供了三种时钟类型：
- std::chrono::system_clock: 代表系统范围的实时挂钟。
- std::chrono::steady_clock: 表示保证永远不会被调整的单调时钟。
- std::chrono::high_resolution_clock: 表示时钟周期最短的时钟。

3. `clock` 时钟提供对当前时间的访问。它由以下元素组成
- std::chrono::time_point: 特定时间点。
- std::chrono::duration: 两个时间点之间的持续时间。
- now(): 返回当前时间点的静态函数。

4. 要将时间点转换为日历表示形式，可以使用 std::chrono::system_clock::to_time_t 函数。

```c++
#include <iostream>
#include <chrono>
#include <thread>
#include <ctime>

int main() {
    std::chrono::time_point<std::chrono::steady_clock> start, end;
 
    start = std::chrono::steady_clock::now();
    std::this_thread::sleep_for(std::chrono::seconds(3)); // 睡眠3秒
    end = std::chrono::steady_clock::now();
 
    std::chrono::duration<double> elapsed_seconds = end - start;
    std::time_t end_time = std::chrono::system_clock::to_time_t(end);
 
    std::cout << "finished computation at " << std::ctime(&end_time)
              << "elapsed time: " << elapsed_seconds.count() << "s\n";
    return 0;
}

Output:

finished computation at Wed Jan  4 05:13:48 2017
elapsed time: 2.14538s
```

此外，C++11还提供了`std::this_thread::sleep_until`函数，它允许线程休眠直到某个指定的未来时间点。这需要传递一个`time_point`对象作为参数。
