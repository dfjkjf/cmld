---
sort: 2
---

# 跨平台开发

## 目的

应用层代码可移植

## 方法

1. 尽量使用标准库
2. 将平台特定的代码封装起来，提供统一的接口。

## 不同平台的差别

### CPU架构
- **指令集**：不同的CPU架构可能支持不同的指令集，如x86、ARM、MIPS等。(编译器已解决)
- **字节序**：大端（Big Endian）和小端（Little Endian）字节序在不同的CPU架构上可能不同。
- **数据类型大小**：`int`、`long`、`指针`的大小在32位和64位系统上可能不同。
- **对齐要求**：不同的CPU对数据对齐可能有不同的要求。
### 编译器
- **编译器支持**：不同的编译器对C/C++标准的支持程度不同，影响可移植性。
- **编译器扩展**：某些编译器可能提供了特定的语言扩展或内置函数，这些在移植时可能需要替换。
- **优化选项**：编译器优化选项在不同的平台上可能有不同的效果。
### 操作系统
- **系统调用**：不同的操作系统提供了不同的系统调用接口，如POSIX、Win32等。
- **线程模型**：线程的实现和调度在不同的操作系统上可能不同。
- **文件系统**：文件系统的路径分隔符、权限模型等在不同操作系统上可能不同。
### 硬件差异
- **内存管理**：不同的硬件平台可能有不同的内存管理机制，如虚拟内存的实现。
- **I/O设备**：不同平台上的I/O设备可能有所不同，需要不同的驱动程序。


## 编译器

编译器在优化代码时可能会重组指令顺序，这可能会影响到原子操作的语义。为了防止这种情况，编译器提供了内存屏障（Memory Barriers）来保证操作的顺序。

C++17标准确实引入了内存模型的概念，并且提供了内存屏障（Memory Barriers）的设施，这些设施可以用来保证操作的顺序和内存操作的可见性，这对于编写无锁数据结构（如无锁队列）尤为重要。

在C++17中，内存屏障是通过以下几种原子操作来提供的：
### `std::atomic_thread_fence`
这个函数提供了不同类型的内存屏障，可以用来创建不同种类的内存顺序约束。以下是一些可用的内存顺序：
- `std::memory_order_relaxed`: 不提供任何内存顺序保证。
- `std::memory_order_acquire`: 提供获取操作，确保后续的读操作不会被重排到这个原子操作之前。
- `std::memory_order_release`: 提供释放操作，确保之前的写操作不会被重排到这个原子操作之后。
- `std::memory_order_acq_rel`: 结合了`acquire`和`release`的顺序。
- `std::memory_order_seq_cst`: 提供序列一致性的最强保证。
### `std::atomic`的成员函数
C++17中的`std::atomic`类型也提供了成员函数，如`store`, `load`, `exchange`, `compare_exchange_weak`, 和 `compare_exchange_strong`，它们可以接受内存顺序参数，以指定所需的内存屏障。
例如，如果你在使用无锁队列，你可能需要确保在某个原子操作之后的所有读操作都能看到该操作的效果，你可以这样做：
```cpp
std::atomic_thread_fence(std::memory_order_release);
```
在修改队列的状态之后，以及在消费者读取队列状态之前，你可以使用：
```cpp
std::atomic_thread_fence(std::memory_order_acquire);
```
通过这些内存屏障，C++17提供了足够的工具来编写符合现代CPU架构的并发数据结构，确保在不同线程之间正确地同步内存访问。
